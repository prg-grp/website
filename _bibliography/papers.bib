---
---

@article{Luthra:2021:TCEP,
  acronym = {JCSS},
  file = {papers/2021_TCEP-Transitions-in-Operator-Placement-to-Adapt-to-Dynamic-Network-Environments.pdf},
  author = {Luthra, Manisha and Koldehofe, Boris and Danger, Niels and Weisenburger, Pascal and Salvaneschi, Guido and Stavrakakis, Ioannis},
  title = {{TCEP}: Transitions in Operator Placement to Adapt to Dynamic Network Environments},
  year = {2021},
  month = dec,
  issue_date = {December, 2012},
  journal = {Journal of Computer and System Sciences},
  volume = {122},
  numpages = {32},
  pages = {94--125},
  publisher = {Elsevier Science Inc.},
  address = {USA},
  issn = {0022-0000},
  doi = {10.1016/j.jcss.2021.05.003},
  keywords = {Complex Event Processing, Operator Placement, Migrations, Adaptations, Transitions, Dynamic Network Environment, Internet of Things},
  abstract = {Distributed Complex Event Processing (DCEP) is a commonly used paradigm to detect and act on situational changes of many applications, including the Internet of Things (IoT). DCEP achieves this using a simple specification of analytical tasks on data streams called operators and their distributed execution on a set of infrastructure. The adaptivity of DCEP to the dynamics of IoT applications is essential and very challenging in the face of changing demands concerning Quality of Service. In our previous work, we addressed this issue by enabling transitions, which allow for the adaptive use of operator placement mechanisms. In this article, we extend the transition methodology by optimizing the costs of transition and analyzing the behavior using multiple operator placement mechanisms. Furthermore, we provide an extensive evaluation on the costs of transition imposed by operator migrations and learning, as it can inflict overhead on the performance if operated uncoordinatedly.},
}

@inproceedings{Oak:2021:EnclaveBased,
  acronym = {SecDev},
  projects = {J<sub>E</sub>},
  file = {papers/2021_Enclave-Based-Secure-Programming-with-JE.pdf},
  author = {Oak, Aditya and Ahmadian, Amir M. and Balliu, Musard and Salvaneschi, Guido},
  title = {Enclave-Based Secure Programming with JE},
  booktitle = {2021 IEEE Secure Development},
  series = {SecDev '21},
  year = {2021},
  month = oct,
  publisher = {IEEE Press},
  address = {Piscataway, NJ, USA},
  abstract = {Over the past few years, major hardware vendors have started offering processors that support Trusted Execution Environments (TEEs) allowing confidential computations over sensitive data on untrusted hosts. Unfortunately, developing applications that use TEEs remains challenging. Current solutions require to use low-level languages (e.g., C/C++) to handle the TEE management process manually -- a complex and error-prone task. Worse, the separation of the application into components that run inside and outside the TEE may lead to information leaks. In summary, TEEs are a powerful means to design secure applications, but there is still a long way to building secure software with TEEs alone. In this work, we present , a programming model for developing TEE-enabled applications where developers only need to annotate Java programs to define application-level security policies and run them securely inside enclaves.},
}

Preliminary entry, update once in ACM
@inproceedings{Sokolowski:2021:Automating,
  acronym = {ESEC/FSE},
  projects = {µs},
  file = {papers/2021_Automating-Serverless-Deployments-for-DevOps-Organizations.pdf},
  author = {Sokolowski, Daniel and Weisenburger, Pascal and Salvaneschi, Guido},
  title = {Automating Serverless Deployments for {DevOps} Organizations},
  booktitle = {Proceedings of the 29th ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering},
  series = {ESEC/FSE '21},
  year = {2021},
  month = aug,
  location = {Athens, Greece},
  publisher = {ACM},
  address = {New York, NY, USA},
  doi = {10.1145/3468264.3468575},
  supp = {https://doi.org/10.5281/zenodo.4888908},
  code = {https://github.com/mjuz-iac/mjuz},
  abstract = {DevOps unifies software development and operations in cross-functional teams to improve software delivery and operations (SDO) performance. Ideally, cross-functional DevOps teams independently deploy their services, but the correct operation of a service often demands other services, requiring coordination to ensure the correct deployment order. This issue is currently solved either with a central deployment or manual out-of-band communication across teams, e.g., via phone, chat, or email. Unfortunately, both contradict the independence of teams, hindering SDO performance -- the reason why DevOps is adopted in the first place. \par In this work, we conduct a study on 73 IT professionals, showing that, in practice, they resort to manual coordination for correct deployments even if they expect better SDO performance with fully automated approaches. To address this issue, we propose μs ([mju:z] ``muse''), a novel IaC system automating deployment coordination in a fully decentralized fashion, still retaining compatibility with DevOps practice -- in contrast to today's solutions. We implement µs, demonstrate that it effectively enables automated coordination, introduces negligible definition overhead, has no performance overhead, and is broadly applicable, as shown by the migration of 64 third-party IaC projects.},
}

Preliminary entry, update once in ACM
@inproceedings{Sokolowski:2021:Deployment,
  acronym = {ESEC/FSE DS},
  projects = {µs},
  file = {papers/2021_Deployment-Coordination-for-Cross-Functional-DevOps-Teams.pdf},
  author = {Sokolowski, Daniel},
  title = {Deployment Coordination for Cross-Functional {DevOps} Teams},
  booktitle = {Proceedings of the 29th ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering},
  series = {ESEC/FSE '21},
  year = {2021},
  month = aug,
  location = {Athens, Greece},
  publisher = {ACM},
  address = {New York, NY, USA},
  doi = {10.1145/3468264.3473101},
  abstract = {Software stability and reliability are the core concerns of DevOps. They are improved by tightening the collaboration between developers and operators in cross-functional teams on the one hand and by automating operations through continuous integration (CI) and infrastructure as code (IaC) on the other hand. Ideally, teams in DevOps are fully independent. Still, their applications often depend on each other in practice, requiring them to coordinate their deployment through centralization or manual coordination.\par With this work, we propose and implement the novel IaC solution µs ([mju:z] ``muse''), which automates deployment coordination in a decentralized fashion. µs is the first approach that is compatible with the DevOps goals as it enables truly independent operations of the DevOps teams. We define our research problem through a questionnaire survey with IT professionals and evaluate the solution by comparing it to other modern IaC approaches, assessing its performance, and applying it to existing IaC programs.},
}

@inproceedings{Sztwiertnia:2021:Impact,
  acronym = {AISTA},
  file = {papers/2021_Impact-of-Programming-Languages-on-Machine-Learning-Bugs.pdf},
  author = {Sztwiertnia, Sebastian and Grübel, Maximilian and Chouchane, Amine and Sokolowski, Daniel and Narasimhan, Krishna and Mezini, Mira},
  title = {Impact of Programming Languages on Machine Learning Bugs},
  booktitle = {Proceedings of the 1st ACM International Workshop on AI and Software Testing/Analysis},
  series = {AISTA '21},
  year = {2021},
  month = jul,
  numpages = {4},
  pages = {9--12},
  location = {Aarhus, Denmark},
  publisher = {ACM},
  address = {New York, NY, USA},
  isbn = {978-1-4503-8541-1},
  doi = {10.1145/3464968.3468408},
  keywords = {Machine Learning, Programming Languages, Empirical Study},
  abstract = {Machine learning (ML) is on the rise to be ubiquitous in modern software. Still, its use is challenging for software developers. So far, research has focused on the ML libraries to find and mitigate these challenges. However, there is initial evidence that programming languages also add to the challenges, identifiable in different distributions of bugs in ML programs. To fill this research gap, we propose the first empirical study on the impact of programming languages on bugs in ML programs. We plan to analyze software from GitHub and related discussions in GitHub issues and Stack Overflow for bug distributions in ML programs, aiming to identify correlations with the chosen programming language, its features and the application domain. This study's results enable better-targeted use of available programming language technology in ML programs, preventing bugs, reducing errors and speeding up development.},
}

@inproceedings{Giallorenzo:2021:Multiparty,
  acronym = {ECOOP},
  projects = {ScalaLoci},
  file = {papers/2021_Multiparty-Languages-The-Choreographic-and-Multitier-Cases.pdf},
  author = {Giallorenzo, Saverio and Montesi, Fabrizio and Peressotti, Marco and Richter, David and Salvaneschi, Guido and Weisenburger, Pascal},
  title = {Multiparty Languages: The Choreographic and Multitier Cases},
  booktitle = {Proceedings of the 35th European Conference on Object-Oriented Programming (ECOOP '21)},
  series = {Leibniz International Proceedings in Informatics (LIPIcs)},
  year = {2021},
  month = jul,
  volume = {194},
  articleno = {22},
  numpages = {27},
  pages = {22:1--22:27},
  editor = {Møller, Anders and Sridharan, Manu},
  location = {Aarhus, Denmark},
  publisher = {Schloss Dagstuhl -- Leibniz-Zentrum für Informatik},
  address = {Dagstuhl, Germany},
  isbn = {978-3-95977-190-0},
  issn = {1868-8969},
  doi = {10.4230/LIPIcs.ECOOP.2021.22},
  url = {https://drops.dagstuhl.de/opus/volltexte/2021/14065},
  urn = {urn:nbn:de:0030-drops-140658},
  keywords = {Distributed Programming, Choreographies, Multitier Languages},
  abstract = {Choreographic languages aim to express multiparty communication protocols, by providing primitives that make interaction manifest. Multitier languages enable programming computation that spans across several tiers of a distributed system, by supporting primitives that allow computation to change the location of execution. Rooted into different theoretical underpinnings---respectively process calculi and lambda calculus---the two paradigms have been investigated independently by different research communities with little or no contact. As a result, the link between the two paradigms has remained hidden for long.\par In this paper, we show that choreographic languages and multitier languages are surprisingly similar. We substantiate our claim by isolating the core abstractions that differentiate the two approaches and by providing algorithms that translate one into the other in a straightforward way. We believe that this work paves the way for joint research and cross-fertilisation among the two communities.},
}

@inproceedings{Oak:2021:Language,
  acronym = {CSF},
  projects = {J<sub>E</sub>},
  file = {papers/2021_Language-Support-for-Secure-Software-Development-with-Enclaves.pdf},
  author = {Oak, Aditya and Ahmadian, Amir M. and Balliu, Musard and Salvaneschi, Guido},
  title = {Language Support for Secure Software Development with Enclaves},
  booktitle = {Proceedings of the 34th IEEE Computer Security Foundations Symposium},
  series = {CSF '21},
  year = {2021},
  month = jun,
  location = {Dubrovnik, Croatia},
  publisher = {IEEE Press},
  address = {Piscataway, NJ, USA},
  abstract = {Confidential computing is a promising technology for securing code and data-in-use on untrusted host machines, e.g., the cloud. Many hardware vendors offer different implementations of Trusted Execution Environments (TEEs). A TEE is a hardware protected execution environment that allows performing confidential computations over sensitive data on untrusted hosts. Despite the appeal of achieving strong security guarantees against low-level attackers, two challenges hinder the adoption of TEEs. First, developing software in high-level managed languages, e.g., Java or Scala, taking advantage of existing TEEs is complex and error-prone. Second, partitioning an application into components that run inside and outside a TEE may break application-level security policies, resulting in an insecure application when facing a realistic attacker.\par In this work, we study both these challenges. We present J<sub>E</sub>, a programming model that seamlessly integrates a TEE, abstracting away low-level programming details such as initialization and loading of data into the TEE. J<sub>E</sub> only requires developers to add annotations to their programs to enable the execution within the TEE. Drawing on information flow control, we develop a security type system that checks confidentiality and integrity policies against realistic attackers with full control over the code running outside the TEE. We formalize the security type system for the J<sub>E</sub> core and prove it sound for a semantic characterization of security. We implement J<sub>E</sub> and the security type system, enable Java programs to run on Intel SGX with strong security guarantees. We evaluate our approach on use cases from the literature, including a battleship game, a secure event processing system, and a popular processing framework for big data, showing that we correctly handle complex cases of partitioning, information flow, declassification, and trust.},
}

@inproceedings{Eskandani:2021:Wonderless,
  acronym = {MSR},
  file = {papers/2021_The-wonderless-Dataset-for-Serverless-Computing.pdf},
  author = {Eskandani, Nafise and Salvaneschi, Guido},
  title = {The Wonderless Dataset for Serverless Computing},
  booktitle = {Proceedings of the IEEE/ACM 18th International Conference on Mining Software Repositories},
  series = {MSR '21},
  year = {2021},
  month = may,
  pages = {565--569},
  location = {Madrid, Spain},
  publisher = {IEEE Computer Society},
  address = {Los Alamitos, CA, USA},
  doi = {10.1109/MSR52588.2021.00075},
  abstract = {Function as a Service (FaaS) has grown in popularity in recent years, with an increasing number of applications following the Serverless computing model. Serverless computing supports out of the box autoscaling in a pay-as-you-go manner, letting developers focus on the application logic rather than worrying about resource management. With the increasing adoption of the this model, researchers have started studying a wide variety of aspects of Serverless computing, including communication, security, performance, and cost optimization. Yet, we still know very little of how Serverless computing is used in practice.\par In this paper, we introduce Wonderless, a novel dataset of open-source Serverless applications. Wonderless consists of 1,877 real-world Serverless applications extracted from GitHub, and it can be used as a data source for further research in the Serverless ecosystem, such as performance evaluation and software mining. To the best of our knowledge, Wonderless is currently the most diverse and largest dataset for research on Serverless computing.},
}

@thesis{Weisenburger:2020:Programming,
  type = {phdthesis},
  projects = {ScalaLoci},
  author = {Weisenburger, Pascal},
  title = {A Programming Language for Distributed Systems},
  year = {2020},
  institution = {Technische Universität Darmstadt},
  address = {Darmstadt, Germany},
  doi = {10.25534/tuprints-00013500},
  url = {http://tuprints.ulb.tu-darmstadt.de/13500/},
  abstract = {Today's software, including many everyday services, such as online streaming, search engines and social networks, is widely distributed, running on top of a network of interconnected computers. Such distributed applications are traditionally developed as separate modules for each component in the distributed system. These modules react to events, like user input or messages from the network, and in turn produce new events for the other modules. Separation into different modules is problematic because combining modules is notoriously hard and requires extensive and time-consuming integration and manual implementation of communication forces programmers to program complex event-based communication schemes among hosts ? an activity which is often low-level and error-prone. The combination of the two results in obscure distributed data flows scattered among multiple modules, hindering reasoning about the system as a whole. For these reasons, despite most software today is distributed, the design and development of distributed systems remains surprisingly challenging.\par We present the ScalaLoci distributed programming language, our approach for taming the complexity of developing distributed applications via specialized programming language support. ScalaLoci addresses the issues above with a coherent model based on placement types that enables reasoning about distributed data flows otherwise scattered across multiple modules, supporting multiple software architectures via dedicated language features and abstracting over low-level communication details and data conversions.\par ScalaLoci does not force developers to modularize software along network boundaries as is traditionally the case when developing distributed systems. Instead, we propose a module system that supports encapsulating each (cross-host) functionality and defining it over abstract peer types. As a result, we disentangle modularization and distribution and we enable the definition of a distributed system as a composition of ScalaLoci modules, each representing a subsystem.\par Our case studies on distributed algorithms, distributed data structures, as well as on real-world distributed streaming engines show that ScalaLoci simplifies developing distributed systems, reduces error-prone communication code and favors early detection of bugs. As we demonstrate, the ScalaLoci module system allows the definition of reusable patterns of interaction in distributed software and enables separating the modularization and distribution concerns, properly separating functionalities in distributed systems.},
}

@article{Zhang:2020:Handling,
  acronym = {OOPSLA},
  author = {Zhang, Yizhou and Salvaneschi, Guido and Myers, Andrew C.},
  title = {Handling Bidirectional Control Flow},
  year = {2020},
  month = nov,
  issue_date = {November 2020},
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {4},
  number = {OOPSLA},
  articleno = {139},
  numpages = {30},
  pages = {139:1--139:30},
  location = {Chicago, IL, USA},
  publisher = {ACM},
  address = {New York, NY, USA},
  issn = {2475-1421},
  doi = {10.1145/3428207},
  keywords = {Type Systems, Iterators, Exceptions, Effect Handlers, Promises, Parametricity},
  abstract = {Pressed by the difficulty of writing asynchronous, event-driven code, mainstream languages have recently been building in support for a variety of advanced control-flow features. Meanwhile, experimental language designs have suggested effect handlers as a unifying solution to programmer-defined control effects, subsuming exceptions, generators, and async--await. However, despite these trends, complex control flow---in particular, control flow that exhibits a bidirectional pattern---remains challenging to manage. \par We introduce \emph{bidirectional algebraic effects}, a new programming abstraction that supports bidirectional control transfer in a more natural way. Handlers of bidirectional effects can raise further effects to transfer control back to the site where the initiating effect was raised, and can use themselves to handle their own effects. We present applications of this expressive power, which falls out naturally as we push toward the unification of effectful programming with object-oriented programming. We pin down the mechanism and the unification formally using a core language that makes generalizations to effect operations and effect handlers.\par The usual propagation semantics of control effects such as exceptions conflicts with modular reasoning in the presence of effect polymorphism---it breaks parametricity. Bidirectionality exacerbates the problem. Hence, we set out to show the core language, which builds on the existing tunneling semantics for algebraic effects, is not only type-safe (no effects go unhandled), but also abstraction-safe (no effects are accidentally handled). We devise a step-indexed logical-relations model, and construct its parametricity and soundness proofs. These core results are fully mechanized in Coq. While a full-featured compiler is left to future work, experiments show that as a first-class language feature, bidirectional handlers can be implemented efficiently.},
}

@inproceedings{Sokolowski:2020:Leveraging,
  acronym = {SuperCompCloud},
  projects = {ScalaLoci},
  file = {papers/2020_Leveraging-Hybrid-Cloud-HPC-with-Multitier-Reactive-Programming.pdf},
  author = {Sokolowski, Daniel and Lehr, Jan-Patrick and Bischof, Christian and Salvaneschi, Guido},
  title = {Leveraging Hybrid Cloud {HPC} with Multitier Reactive Programming},
  booktitle = {Proceedings of the 3rd IEEE/ACM International Workshop on Interoperability of Supercomputing and Cloud Technologies},
  series = {SuperCompCloud '20},
  year = {2020},
  month = nov,
  pages = {27--32},
  location = {Atlanta, GA, USA},
  doi = {10.1109/SuperCompCloud51944.2020.00010},
  keywords = {High Performance Computing, Hybrid Cloud Computing, Multitier Programming, Reactive Programming},
  abstract = {The advent of cloud computing has enabled large-scale availability of on-demand computing and storage resources. However, these benefits are not yet at the fingertips of HPC developers: Typical HPC applications use on-premise computing resources and rely on static deployment setups, reliable hardware, and rather homogeneous resources. This hinders (partial) execution in the cloud, even though applications could benefit from scaling beyond on-premise resources and from the variety of hardware available in the cloud to speed up execution.\par To address this issue, we orchestrate computationally intensive kernels using a high-level programming language that ensures advanced optimization and improves execution flexibility-enabling hybrid cloud/on-premise HPC deployments. Our approach is based on multitier reactive programming, where distributed code is defined within the same compilation unit and computations are placed explicitly using placement types. We adjust placement based on performance characteristics measured before execution, apply our approach to a shortest vector problem (SVP) solver from cryptanalysis, and evaluate it to be effective.},
}

@article{Köhler:2020:Rethinking,
  acronym = {OOPSLA},
  projects = {ConSysT},
  file = {papers/2020_Rethinking-Safe-Consistency-In-Distributed-Object-Oriented-Programming.pdf},
  author = {Köhler, Mirko and Eskandani, Nafise and Weisenburger, Pascal and Margara, Alessandro and Salvaneschi, Guido},
  title = {Rethinking Safe Consistency in Distributed Object-Oriented Programming},
  year = {2020},
  month = nov,
  issue_date = {November 2020},
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {4},
  number = {OOPSLA},
  articleno = {188},
  numpages = {30},
  pages = {188:1--188:30},
  location = {Chicago, IL, USA},
  publisher = {ACM},
  address = {New York, NY, USA},
  issn = {2475-1421},
  doi = {10.1145/3428256},
  keywords = {Consistency, Replication, Java, Type Systems},
  abstract = {Large scale distributed systems require to embrace the trade off between consistency and availability, accepting lower levels of consistency to guarantee higher availability. Existing programming languages are, however, agnostic to this compromise, resulting in consistency guarantees that are the same for the whole application and are implicitly adopted from the middleware or hardcoded in configuration files.\par In this paper, we propose to integrate availability in the design of an object-oriented language, allowing developers to specify different consistency and isolation constraints in the same application at the granularity of single objects. We investigate how availability levels interact with object structure and define a type system that preserves correct program behavior. Our evaluation shows that our solution performs efficiently and improves the design of distributed applications.},
}

@article{Weisenburger:2020:Survey,
  acronym = {CSUR},
  projects = {ScalaLoci},
  file = {papers/2020_A-Survey-of-Multitier-Programming.pdf},
  author = {Weisenburger, Pascal and Wirth, Johannes and Salvaneschi, Guido},
  title = {A Survey of Multitier Programming},
  year = {2020},
  month = sep,
  issue_date = {September 2020},
  journal = {ACM Computing Surveys},
  volume = {53},
  number = {4},
  articleno = {81},
  numpages = {35},
  pages = {81:1--81:35},
  publisher = {ACM},
  address = {New York, NY, USA},
  issn = {0360-0300},
  doi = {10.1145/3397495},
  keywords = {Distributed Programming, Multitier Languages, Tierless Languages},
  abstract = {Multitier programming deals with developing the components that pertain to different tiers in the system (e.g., client and server), mixing them in the same compilation unit. In this paradigm, the code for different tiers is then either generated at run time or it results from the compiler splitting the codebase into components that belong to different tiers based on user annotations, static analysis, types, or a combination of these. In the Web context, multitier languages aim at reducing the distinction between client and server code, by translating the code that is to be executed on the clients to JavaScript or by executing JavaScript on the server, too. Ultimately, the goal of the multitier approach is to improve program comprehension, simplify maintenance and enable formal reasoning about the properties of the whole distributed application.\par A number of multitier research languages have been proposed over the last decade, which support various degrees of multitier programming and explore different design tradeoffs. In this article, we provide an overview of the existing solutions, discuss their positioning in the design space, and outline open research problems.},
}

@inproceedings{Helm:2020:Programming,
  acronym = {ISSTA},
  author = {Helm, Dominik and Kübler, Florian and Kölzer, Jan Thomas and Haller, Philipp and Eichberg, Michael and Salvaneschi, Guido and Mezini, Mira},
  title = {A Programming Model for Semi-Implicit Parallelization of Static Analyses},
  booktitle = {Proceedings of the 29th ACM SIGSOFT International Symposium on Software Testing and Analysis},
  series = {ISSTA '20},
  year = {2020},
  month = jul,
  numpages = {12},
  pages = {428--439},
  location = {Los Angeles, CA, USA},
  publisher = {ACM},
  address = {New York, NY, USA},
  isbn = {978-1-4503-8008-9},
  doi = {10.1145/3395363.3397367},
  keywords = {Static Analysis, Parallelization, Concurrency},
  abstract = {Parallelization of static analyses is necessary to scale to real-world programs, but it is a complex and difficult task and, therefore, often only done manually for selected high-profile analyses. In this paper, we propose a programming model for semi-implicit parallelization of static analyses which is inspired by reactive programming. Reusing the domain-expert knowledge on how to parallelize anal- yses encoded in the programming framework, developers do not need to think about parallelization and concurrency issues on their own. The programming model supports stateful computations, only requires monotonic computations over lattices, and is independent of specific analyses. Our evaluation shows the applicability of the programming model to different analyses and the importance of user-selected scheduling strategies. We implemented an IFDS solver that was able to outperform a state-of-the-art, specialized parallel IFDS solver both in absolute performance and scalability.},
}

@inproceedings{Köhler:2020:ConSysT,
  acronym = {FTfJP},
  projects = {ConSysT},
  author = {Köhler, Mirko and Eskandani, Nafise and Margara, Alessandro and Salvaneschi, Guido},
  title = {{ConSysT}: Tunable, Safe Consistency Meets Object-Oriented Programming},
  booktitle = {Proceedings of the 22nd ACM SIGPLAN International Workshop on Formal Techniques for Java-Like Programs},
  series = {FTfJP '20},
  year = {2020},
  month = jul,
  numpages = {3},
  pages = {15--17},
  location = {Berlin, Germany},
  publisher = {ACM},
  address = {New York, NY, USA},
  isbn = {978-1-4503-8186-4},
  doi = {10.1145/3427761.3428346},
  keywords = {Java, Consistency, Replication, Type Systems},
  abstract = {Data replication is essential in scenarios like geo-distributed datacenters, but poses challenges for data consistency. Developers adopt Strong consistency at the cost of performance or embrace Weak consistency and face a higher programming complexity. We argue that languages should associate consistency to data types. We present , a programming language and middleware that provides abstractions to specify consistency types, enabling mixing different consistency levels in the same application. Such mechanism is fully integrated with object-oriented programming and type system guarantees that different levels can only be mixed correctly.},
}

@article{Weisenburger:2020:Implementing,
  acronym = {‹Programming›},
  projects = {ScalaLoci},
  file = {papers/2020_Implementing-a-Language-for-Distributed-Systems.pdf},
  author = {Weisenburger, Pascal and Salvaneschi, Guido},
  title = {Implementing a Language for Distributed Systems: Choices and Experiences with Type Level and Macro Programming in {Scala}},
  year = {2020},
  month = feb,
  journal = {The Art, Science, and Engineering of Programming},
  volume = {4},
  number = {3},
  articleno = {17},
  numpages = {29},
  pages = {17:1--17:29},
  location = {Porto, Portugal},
  publisher = {AOSA, Inc},
  issn = {2473-7321},
  doi = {10.22152/programming-journal.org/2020/4/17},
  keywords = {Distributed Programming, Multitier Programming, Type Level Programming, Macro System, Scala},
  code = {https://github.com/scala-loci},
  website = {https://scala-loci.github.io/},
  abstract = {Multitier programming languages reduce the complexity of developing distributed systems by developing the distributed system in a single coherent code base. The compiler or the runtime separate the code for the components of the distributed system, enabling abstraction over low level implementation details such as data representation, serialization and network protocols. Our ScalaLoci language allows developers to declare the different components and their architectural relation at the type level, allowing static reasoning about about distribution and remote communication and guaranteeing static type safety across components. The compiler splits the multitier program into the component-specific code and automatically generates the communication boilerplate. Communication between components can be modeled by declaratively specifying data flows between components using reactive programming.\par In this paper, we report on the implementation of our design and our experience with embedding our language features into Scala as a host language. We show how a combination of Scala's advanced type level programming and its macro system can be used to enrich the language with new abstractions. We comment on the challenges we encountered and the solutions we developed for our current implementation and outline suggestions for an improved macro system to support the such use cases of embedding of domain-specific abstractions.},
}

@inproceedings{Köhler:2019:Automated,
  acronym = {ASE},
  file = {papers/2019_Automated-Refactoring-to-Reactive-Programming.pdf},
  author = {Köhler, Mirko and Salvaneschi, Guido},
  title = {Automated Refactoring to Reactive Programming},
  booktitle = {Proceedings of the 34th IEEE/ACM International Conference on Automated Software Engineering},
  series = {ASE '19},
  year = {2019},
  month = nov,
  numpages = {12},
  pages = {835--846},
  location = {San Diego, CA, USA},
  publisher = {IEEE Press},
  address = {Piscataway, NJ, USA},
  isbn = {978-1-7281-2508-4},
  doi = {10.1109/ASE.2019.00082},
  keywords = {Refactoring, Reactive Programming, Asynchronous Programming, Java},
  abstract = {Reactive programming languages and libraries, such as ReactiveX, have been shown to significantly improve software design and have seen important industrial adoption over the last years. Asynchronous applications - which are notoriously error-prone to implement and to maintain - greatly benefit from reactive programming because they can be defined in a declarative style, which improves code clarity and extensibility.\par In this paper, we tackle the problem of refactoring existing software that has been designed with traditional abstractions for asynchronous programming. We propose 2Rx, a refactoring approach to automatically convert asynchronous code to reactive programming. Our evaluation on top-starred GitHub projects shows that 2Rx is effective with common asynchronous constructs and it can provide a refactoring for 91.7% of their occurrences.},
}

@inproceedings{Schindelhauer:2019:Collaborative,
  acronym = {ALGOSENSORS},
  author = {Schindelhauer, Christian and Oak, Aditya and Janson, Thomas},
  title = {Collaborative Broadcast in $\mathcal{O}(\log{} \log{} n)$ Rounds},
  booktitle = {Proceedings of the International Symposium on Algorithms and Experiments for Sensor Systems, Wireless Networks and Distributed Robotics},
  series = {ALGOSENSORS '19},
  year = {2019},
  month = nov,
  pages = {119--136},
  editor = {Dressler, Falko and Scheideler, Christian},
  location = {Pisa, Italy},
  publisher = {Springer International Publishing},
  address = {Cham, Switzerland},
  isbn = {978-3-030-34405-4},
  doi = {10.1007/978-3-030-34405-4_7},
  abstract = {We consider the multihop broadcasting problem for n nodes placed uniformly at random in a disk and investigate the number of hops required to transmit a signal from the central node to all other nodes under three communication models: Unit-Disk-Graph (UDG), Signal-to-Noise-Ratio (SNR), and the wave superposition model of multiple input/multiple output (MIMO).},
}

@article{Mogk:2019:FaultTolerant,
  acronym = {OOPSLA},
  projects = {REScala},
  author = {Mogk, Ragnar and Drechsler, Joscha and Salvaneschi, Guido and Mezini, Mira},
  title = {A Fault-Tolerant Programming Model for Distributed Interactive Applications},
  year = {2019},
  month = oct,
  issue_date = {October 2019},
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {3},
  number = {OOPSLA},
  articleno = {144},
  numpages = {29},
  pages = {144:1--144:29},
  location = {Athens, Greece},
  publisher = {ACM},
  address = {New York, NY, USA},
  issn = {2475-1421},
  doi = {10.1145/3360570},
  keywords = {Distributed Systems, Fault Tolerance, Interactive Applications},
  abstract = {Ubiquitous connectivity of web, mobile, and IoT computing platforms has fostered a variety of distributed applications with decentralized state. These applications execute across multiple devices with varying reliability and connectivity. Unfortunately, there is no declarative fault-tolerant programming model for distributed interactive applications with an inherently decentralized system model.\par We present a novel approach to automating fault tolerance using high-level programming abstractions tailored to the needs of distributed interactive applications. Specifically, we propose a calculus that enables formal reasoning about applications' dataflow within and across individual devices. Our calculus reinterprets the functional reactive programming model to seamlessly integrate its automated state change propagation with automated crash recovery of device-local dataflow and disconnection-tolerant distribution with guaranteed automated eventual consistency semantics based on conflict-free replicated datatypes. As a result, programmers are relieved of handling intricate details of distributing change propagation and coping with distribution failures in the presence of interactivity. We also provides proofs of our claims, an implementation of our calculus, and an empirical evaluation using a common interactive application.},
}

@inproceedings{Eskandani:2019:Distributed,
  acronym = {SPLASH Companion},
  projects = {ConSysT},
  author = {Eskandani, Nafise and Köhler, Mirko and Margara, Alessandro and Salvaneschi, Guido},
  title = {Distributed Object-Oriented Programming with Multiple Consistency Levels in {ConSysT}},
  booktitle = {Companion Proceedings of the 2019 ACM SIGPLAN International Conference on Systems, Programming, Languages, and Applications: Software for Humanity},
  series = {SPLASH Companion '19},
  year = {2019},
  month = oct,
  numpages = {2},
  pages = {13--14},
  location = {Athens, Greece},
  publisher = {ACM},
  address = {New York, NY, USA},
  isbn = {978-1-4503-6992-3},
  doi = {10.1145/3359061.3362779},
  keywords = {Distributed Systems, Java, Replication, Type Systems, Consistency},
  abstract = {Data replication is essential in scenarios like geo-distributed datacenters and edge computing. Yet, it poses a challenge for data consistency. Developers either adopt high consistency at the detriment of performance or they embrace low consistency and face a much higher programming complexity. We argue that language abstractions should support associating the level of consistency to data types. We present ConSysT, a programming language and middleware that provides abstractions to specify consistency types, enabling mixing different consistency levels in the same application. Such mechanism is fully integrated with object-oriented programming and type system guarantees that different levels can be mixed only in a correct way.},
}

@inproceedings{Blöcher:2019:Grass,
  acronym = {REBLS},
  file = {papers/2019_GRASS-Generic-Reactive-Application-Specific-Scheduling.pdf},
  author = {Blöcher, Marcel and Eichholz, Matthias and Weisenburger, Pascal and Eugster, Patrick and Mezini, Mira and Salvaneschi, Guido},
  title = {{GRASS}: Generic Reactive Application-Specific Scheduling},
  booktitle = {Proceedings of the 6th ACM SIGPLAN International Workshop on Reactive and Event-Based Languages and Systems},
  series = {REBLS '19},
  year = {2019},
  month = oct,
  numpages = {10},
  pages = {21--30},
  location = {Athens, Greece},
  publisher = {ACM},
  address = {New York, NY, USA},
  isbn = {978-1-4503-6986-2},
  doi = {10.1145/3358503.3361274},
  keywords = {Reactive Programming, Data Center Resource Scheduling},
  abstract = {High resource utilization is important to operate compute infrastructures and data centers efficiently. High utilization is achieved by multiplexing several applications over the same physical infrastructure. Yet, with this approach, the different requirements of each application have to be taken into account when scheduling resources.\par We propose GRASS, a reactive domain-specific abstraction that allows specifying application-tailored resource scheduling policies. We demonstrate how the declarative approach of GRASS enables extension and composition of scheduling policies. Our evaluation shows the performance benefits of considering application-specific information in a composition of scheduling policies that adapt at run time.},
}

@article{Salvaneschi:2019:LanguageIntegrated,
  acronym = {OOPSLA},
  author = {Salvaneschi, Guido and Köhler, Mirko and Sokolowski, Daniel and Haller, Philipp and Erdweg, Sebastian and Mezini, Mira},
  title = {Language-Integrated Privacy-Aware Distributed Queries},
  year = {2019},
  month = oct,
  issue_date = {October 2019},
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {3},
  number = {OOPSLA},
  articleno = {167},
  numpages = {30},
  pages = {167:1--167:30},
  location = {Athens, Greece},
  publisher = {ACM},
  address = {New York, NY, USA},
  issn = {2475-1421},
  doi = {10.1145/3360593},
  keywords = {Information-Flow Type System, Scala, Operator Placement, SQL, Data Privacy},
  abstract = {Distributed query processing is an effective means for processing large amounts of data. To abstract from the technicalities of distributed systems, algorithms for operator placement automatically distribute sequential data queries over the available processing units. However, current algorithms for operator placement focus on performance and ignore privacy concerns that arise when handling sensitive data.\par We present a new methodology for privacy-aware operator placement that both prevents leakage of sensitive information and improves performance. Crucially, our approach is based on an information-flow type system for data queries to reason about the sensitivity of query subcomputations. Our solution unfolds in two phases. First, placement space reduction generates deployment candidates based on privacy constraints using a syntax-directed transformation driven by the information-flow type system. Second, constraint solving selects the best placement among the candidates based on a cost model that maximizes performance. We verify that our algorithm preserves the sequential behavior of queries and prevents leakage of sensitive data. We implemented the type system and placement algorithm for a new query language SecQL and demonstrate significant performance improvements in benchmarks.},
}

@misc{Sokolowski:2019:Multitier,
  acronym = {REBLS},
  projects = {ScalaLoci},
  file = {papers/2019_Multitier-Reactive-Programming-in-High-Performance-Computing.pdf},
  author = {Sokolowski, Daniel and Martens, Philipp and Salvaneschi, Guido},
  title = {Multitier Reactive Programming in High Performance Computing},
  year = {2019},
  month = oct,
  howpublished = {Presentation at the 6th Workshop on Reactive and Event-based Languages and Systems (REBLS '19)},
  location = {Athens, Greece},
  url = {https://2019.splashcon.org/details/rebls-2019-papers/2/Multitier-Reactive-Programming-in-High-Performance-Computing},
  keywords = {High Performance Computing, Reactive Programming, Tierless Programming},
  abstract = {High Performance Computing (HPC) is crucial in a number of sectors, including weather forecasts, particle simulations and fluid dynamics. Existing programming frameworks for HPC expose developers to low-level details such as message passing and explicit memory management, which are hard to program and error-prone.\par In this paper, we present ongoing work on increasing the level of abstraction for HPC. We tackle this problem with an approach based on a combination of multitier programming and reactive programming which enables the development of complex processor configurations in a uniform way using event streams as communication pattern. We report our experience with LULESH, a well known HPC benchmark, and we outline our research roadmap.},
}

@inproceedings{Baumgärtner:2019:Smart,
  acronym = {GHTC},
  file = {papers/2019_Smart-Street-Lights-and-Mobile-Citizen-Apps-for-Resilient-Communication-in-a-Digital-City.pdf},
  author = {Baumgärtner, Lars and Höchst, Jonas and Lampe, Patrick and Mogk, Ragnar and Sterz, Artur and Weisenburger, Pascal and Mezini, Mira and Freisleben, Bernd},
  title = {Smart Street Lights and Mobile Citizen Apps for Resilient Communication in a Digital City},
  booktitle = {Proceedings of the 2019 IEEE Global Humanitarian Technology Conference},
  series = {GHTC '19},
  year = {2019},
  month = oct,
  numpages = {8},
  location = {Seattle, WA, USA},
  publisher = {IEEE Press},
  address = {Piscataway, NJ, USA},
  isbn = {978-1-7281-1781-2},
  doi = {10.1109/GHTC46095.2019.9033134},
  abstract = {While information and communication technology is crucial for the operation of urban infrastructures and the well-being of its inhabitants, current technology is quite vulnerable to disruptions of various kinds. In future smart cities, a more resilient urban infrastructure is imperative to handle the increasing number of hazardous situations. We present a novel resilient communication approach based on smart street lights as part of the public infrastructure. It supports people in their everyday life and adapts its functionality to the challenges of emergency situations. Our approach relies on various environmental sensors and in-situ processing for automatic situation assessment, and a range of communication mechanisms for maintaining a communication network. Furthermore, resilience is not only achieved based on infrastructure deployed by a digital city's municipality, but also based on integrating citizens through software that runs on their mobile devices. Web-based zero-installation and platform-agnostic apps can switch to device-to-device communication to continue benefiting people even during a disaster situation. Our approach, featuring a covert channel for professional responders and a zero-installation app, is evaluated through a prototypical implementation based on a commercially available street light.},
}

@inproceedings{Eichholz:2019:TypeSafe,
  acronym = {ECOOP},
  author = {Eichholz, Matthias and Campbell, Eric and Foster, Nate and Salvaneschi, Guido and Mezini, Mira},
  title = {How to Avoid Making a Billion-Dollar Mistake: Type-Safe Data Plane Programming with {SafeP4}},
  booktitle = {Proceedings of the 33rd European Conference on Object-Oriented Programming (ECOOP '19)},
  series = {Leibniz International Proceedings in Informatics (LIPIcs)},
  year = {2019},
  month = jul,
  volume = {134},
  articleno = {12},
  numpages = {28},
  pages = {12:1--12:28},
  editor = {Donaldson, Alastair F.},
  location = {London, UK},
  publisher = {Schloss Dagstuhl -- Leibniz-Zentrum für Informatik},
  address = {Dagstuhl, Germany},
  isbn = {978-3-95977-111-5},
  issn = {1868-8969},
  doi = {10.4230/LIPIcs.ECOOP.2019.12},
  url = {http://drops.dagstuhl.de/opus/volltexte/2019/10804},
  urn = {urn:nbn:de:0030-drops-108041},
  keywords = {P4, Data Plane Programming, Type Systems},
  abstract = {The P4 programming language offers high-level, declarative abstractions that bring the flexibility of software to the domain of networking. Unfortunately, the main abstraction used to represent packet data in P4, namely header types, lacks basic safety guarantees. Over the last few years, experience with an increasing number of programs has shown the risks of the unsafe approach, which often leads to subtle software bugs.\par This paper proposes SafeP4, a domain-specific language for programmable data planes in which all packet data is guaranteed to have a well-defined meaning and satisfy essential safety guarantees. We equip SafeP4 with a formal semantics and a static type system that statically guarantees header validity -- a common source of safety bugs according to our analysis of real-world P4 programs. Statically ensuring header validity is challenging because the set of valid headers can be modified at runtime, making it a dynamic program property. Our type system achieves static safety by using a form of path-sensitive reasoning that tracks dynamic information from conditional statements, routing tables, and the control plane. Our evaluation shows that SafeP4's type system can effectively eliminate common failures in many real-world programs.},
}

@inproceedings{Weisenburger:2019:Multitier,
  acronym = {ECOOP},
  projects = {ScalaLoci},
  file = {papers/2019_Multitier-Modules.pdf},
  author = {Weisenburger, Pascal and Salvaneschi, Guido},
  title = {Multitier Modules},
  booktitle = {Proceedings of the 33rd European Conference on Object-Oriented Programming (ECOOP '19)},
  series = {Leibniz International Proceedings in Informatics (LIPIcs)},
  year = {2019},
  month = jul,
  volume = {134},
  articleno = {3},
  numpages = {29},
  pages = {3:1--3:29},
  editor = {Donaldson, Alastair F.},
  location = {London, UK},
  publisher = {Schloss Dagstuhl -- Leibniz-Zentrum für Informatik},
  address = {Dagstuhl, Germany},
  isbn = {978-3-95977-111-5},
  issn = {1868-8969},
  doi = {10.4230/LIPIcs.ECOOP.2019.3},
  url = {http://drops.dagstuhl.de/opus/volltexte/2019/10795},
  urn = {urn:nbn:de:0030-drops-107957},
  keywords = {Distributed Programming, Multitier Programming, Abstract Peer Types, Placement Types, Module Systems, Scala},
  code = {https://github.com/scala-loci},
  website = {https://scala-loci.github.io/},
  abstract = {Multitier programming languages address the complexity of developing distributed systems abstracting over low level implementation details such as data representation, serialization and network protocols. Since the functionalities of different peers can be defined in the same compilation unit, multitier languages do not force developers to modularize software along network boundaries. Unfortunately, combining the code for all tiers into the same compilation unit poses a scalability challenge or forces developers to resort to traditional modularization abstractions that are agnostic to the multitier nature of the language.\par In this paper, we address this issue with a module system for multitier languages. Our module system supports encapsulating each (cross-peer) functionality and defining it over abstract peer types. As a result, we disentangle modularization and distribution and we enable the definition of a distributed system as a composition of multitier modules, each representing a subsystem. Our case studies on distributed algorithms, distributed data structures, as well as on the Apache Flink task distribution system, show that multitier modules allow the definition of reusable (abstract) patterns of interaction in distributed software and enable separating the modularization and distribution concerns, properly separating functionalities in distributed systems.},
}

@misc{Bračevac:2019:TypeSafe,
  acronym = {CoRR},
  author = {Bračevac, Oliver and Salvaneschi, Guido and Erdweg, Sebastian and Mezini, Mira},
  title = {Type-safe, Polyvariadic Event Correlation},
  year = {2019},
  month = jul,
  eprint = {1907.02990},
  eprinttype = {arXiv},
  abstract = {The pivotal role that event correlation technology plays in todays applications has lead to the emergence of different families of event correlation approaches with a multitude of specialized correlation semantics, including computation models that support the composition and extension of different semantics.\par However, type-safe embeddings of extensible and composable event patterns into statically-typed generalpurpose programming languages have not been systematically explored so far. This is unfortunate, as typesafe embedding of event patterns is important to enable increased correctness of event correlation computations as well as domain-specific optimizations. Event correlation technology has often adopted well-known and intuitive notations from database queries, for which approaches to type-safe embedding do exist. However, we argue in the paper that these approaches, which are essentially descendants of the work on monadic comprehensions, are not well-suited for event correlations and, thus, cannot without further ado be reused/repurposed for embedding event patterns.\par To close this gap we propose PolyJoin, a novel approach to type-safe embedding for fully polyvariadic event patterns with polymorphic correlation semantics. Our approach is based on a tagless final encoding with uncurried higher-order abstract syntax (HOAS) representation of event patterns withn variables, for arbitrary $n \in{} \mathbb{N}$. Thus, our embedding is defined in terms of the host language without code generation and exploits the host language type system to model and type check the type system of the pattern language. Hence, by construction it impossible to define ill-typed patterns. We show that it is possible to have a purely \emph{library-level} embedding of event patterns, in the familiar join query notation, which is not restricted to monads. PolyJoin is practical, type-safe and extensible. An implementation of it in pure multicore OCaml is readily usable.},
}

@inproceedings{Casadei:2019:ContextOrientation,
  acronym = {FAS*W},
  author = {Casadei, Roberto and Pianini, Danilo and Salvaneschi, Guido and Viroli, Mirko},
  title = {On Context-Orientation in Aggregate Programming},
  booktitle = {Proceedings of the 2019 IEEE 4th International Workshops on Foundations and Applications of Self* Systems},
  series = {FAS*W '19},
  year = {2019},
  month = jun,
  pages = {92--97},
  location = {Umeå, Sweden},
  isbn = {978-1-7281-2407-0},
  doi = {10.1109/FAS-W.2019.00035},
  keywords = {Aggregate Programming, Context-Oriented Programming, Collective Adaptive Systems, Context-Aware Systems},
  abstract = {Context-awareness plays a central role in selfadaptive software. By a programming perspective, context is often used implicitly, and context-aware code is fragmented in the codebase. In Context-Oriented Programming, instead, context is considered a first-class citizen and is explicitly used to modularise context-sensitive functionality and behavioural variability. In this paper, we reflect on the role of context in collective adaptive systems, by a discussion from the special perspective of a macro paradigm, Aggregate Programming, which supports the specification of collective behaviour by a global perspective through functional compositions of field computations. In particular, we consider the abstractions exposed in Context-Oriented and Aggregate Programming, suggest potential synergies in both directions, and accordingly take the first steps towards a combined design},
}

@inproceedings{Weisenburger:2019:Developing,
  acronym = {DEBS},
  projects = {ScalaLoci},
  file = {papers/2019_Developing-Distributed-Systems-with-Multitier-Programming.pdf},
  author = {Weisenburger, Pascal and Salvaneschi, Guido},
  title = {Tutorial: Developing Distributed Systems with Multitier Programming},
  booktitle = {Proceedings of the 13th ACM International Conference on Distributed and Event-Based Systems},
  series = {DEBS '19},
  year = {2019},
  month = jun,
  numpages = {2},
  pages = {203--204},
  location = {Darmstadt, Germany},
  publisher = {ACM},
  address = {New York, NY, USA},
  isbn = {978-1-4503-6794-3},
  doi = {10.1145/3328905.3332465},
  keywords = {Scala, Placement Types, Reactive Programming, Multitier Programming, Distributed Programming},
  abstract = {Developing distributed systems is a complex task that requires to program different peers, often using several languages on different platforms, writing communication code and handling data serialization and conversion.\par We show how the multitier programming paradigm can alleviate these issues, supporting a development model where all peers in the system can be written in the same language and coexist in the same compilation units, communication code is automatically inserted by the compiler and the language abstracts over data conversion and serialization. We present multitier programming abstractions, discuss their applicability step by step for the development of small applications and discuss larger case studies on distributed stream processing, like Apache Flink and Apache Gearpump.},
}

@inproceedings{Oak:2019:Language,
  acronym = {PASS},
  projects = {J<sub>E</sub>},
  author = {Oak, Aditya and Mezini, Mira and Salvaneschi, Guido},
  title = {Language Support for Multiple Privacy Enhancing Technologies},
  booktitle = {Companion Proceedings of the 3rd International Conference on Art, Science, and Engineering of Programming},
  series = {‹Programming› Companion '19},
  year = {2019},
  month = apr,
  articleno = {12},
  numpages = {2},
  pages = {12:1--12:2},
  location = {Genova, Italy},
  publisher = {ACM},
  address = {New York, NY, USA},
  isbn = {978-1-4503-6257-3},
  doi = {10.1145/3328433.3328446},
  keywords = {Programming Languages, Information Flow Control},
  abstract = {Privacy is one of the critical aspects in the design of computing systems. Various techniques are being used to enforce privacy, such as information flow control, symmetric/asymmetric cryptography, secure computing enclaves, partial homomorphic encryption and differential privacy. These mechanisms should ideally be combined in complex software systems as they offer different properties and performance trade offs. Unfortunately, reasoning about the privacy properties of such combination is still an open research problem.\par In this paper, we present our vision on a programming language in which we incorporate different privacy preservation techniques in a common programming model.},
}

@article{Weisenburger:2018:Distributed,
  acronym = {OOPSLA},
  projects = {ScalaLoci},
  file = {papers/2018_Distributed-System-Development-with-ScalaLoci.pdf},
  author = {Weisenburger, Pascal and Köhler, Mirko and Salvaneschi, Guido},
  title = {Distributed System Development with {ScalaLoci}},
  year = {2018},
  month = oct,
  issue_date = {October 2018},
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {2},
  number = {OOPSLA},
  articleno = {129},
  numpages = {30},
  pages = {129:1--129:30},
  location = {Boston, MA, USA},
  publisher = {ACM},
  address = {New York, NY, USA},
  issn = {2475-1421},
  doi = {10.1145/3276499},
  keywords = {Reactive Programming, Placement Types, Distributed Programming, Scala, Multitier Programming},
  code = {https://github.com/scala-loci},
  website = {https://scala-loci.github.io/},
  abstract = {Distributed applications are traditionally developed as separate modules, often in different languages, which react to events, like user input, and in turn produce new events for the other modules. Separation into components requires time-consuming integration. Manual implementation of communication forces programmers to deal with low-level details. The combination of the two results in obscure distributed data flows scattered among multiple modules, hindering reasoning about the system as a whole. The ScalaLoci distributed programming language addresses these issues with a coherent model based on placement types that enables reasoning about distributed data flows, supporting multiple software architectures via dedicated language features and abstracting over low-level communication details and data conversions. As we show, ScalaLoci simplifies developing distributed systems, reduces error-prone communication code and favors early detection of bugs.},
}

@article{Drechsler:2018:ThreadSafe,
  acronym = {OOPSLA},
  projects = {REScala},
  file = {papers/2018-Thread-safe-reactive-programming.pdf},
  author = {Drechsler, Joscha and Mogk, Ragnar and Salvaneschi, Guido and Mezini, Mira},
  title = {Thread-Safe Reactive Programming},
  year = {2018},
  month = oct,
  issue_date = {November 2018},
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {2},
  number = {OOPSLA},
  articleno = {107},
  numpages = {30},
  pages = {107:1--107:30},
  location = {Boston, MA, USA},
  publisher = {ACM},
  address = {New York, NY, USA},
  issn = {2475-1421},
  doi = {10.1145/3276477},
  keywords = {Reactive Programming, Concurrency, Transactions},
  abstract = {The execution of an application written in a reactive language involves transfer of data and control flow between imperative and reactive abstractions at well-defined points. In a multi-threaded environment, multiple such interactions may execute concurrently, potentially causing data races and event ordering ambiguities. Existing RP languages either disable multi-threading or handle it at the cost of reducing expressiveness or weakening consistency. This paper proposes a model for thread-safe reactive programming (RP) that ensures abort-free strict serializability under concurrency while sacrificing neither expressiveness nor consistency. We also propose an architecture for integrating a corresponding scheduler into the RP language runtime, such that thread-safety is provided "out-of-the-box" to the applications.\par We show the feasibility of our proposal by providing and evaluating a ready-to-use implementation integrated into the REScala programming language. The scheduling algorithm is formally proven correct. A thorough empirical evaluation shows that reactive applications build on top of it scale with multiple threads, while the scheduler incurs acceptable performance overhead in a single-threaded configuration. The scalability enabled by our scheduler is roughly on-par with that of hand-crafted application-specific locking and better than the scalability enabled by a scheduler using an off-the-shelf software transactional memory library.},
}

@inproceedings{Mogk:2018:FaultTolerant,
  acronym = {ECOOP},
  projects = {REScala},
  file = {papers/2018_Fault-tolerant-Distributed-Reactive-Programming.pdf},
  author = {Mogk, Ragnar and Baumgärtner, Lars and Salvaneschi, Guido and Freisleben, Bernd and Mezini, Mira},
  title = {Fault-tolerant Distributed Reactive Programming},
  booktitle = {Proceedings of the 32nd European Conference on Object-Oriented Programming (ECOOP '18)},
  series = {Leibniz International Proceedings in Informatics (LIPIcs)},
  year = {2018},
  month = jul,
  volume = {109},
  articleno = {1},
  numpages = {26},
  pages = {1:1--1:26},
  editor = {Millstein, Todd},
  location = {Amsterdam, Netherlands},
  publisher = {Schloss Dagstuhl -- Leibniz-Zentrum für Informatik},
  address = {Dagstuhl, Germany},
  isbn = {978-3-95977-079-8},
  issn = {1868-8969},
  doi = {10.4230/LIPIcs.ECOOP.2018.1},
  url = {http://drops.dagstuhl.de/opus/volltexte/2018/9206},
  urn = {urn:nbn:de:0030-drops-92064},
  keywords = {Reactive Programming, Distributed Systems, CRDTs, Snapshots, Restoration, Error Handling, Fault Tolerance},
  abstract = {In this paper, we present a holistic approach to provide fault tolerance for distributed reactive programming. Our solution automatically stores and recovers program state to handle crashes, automatically updates and shares distributed parts of the state to provide eventual consistency, and handles errors in a fine-grained manner to allow precise manual control when necessary. By making use of the reactive programming paradigm, we provide these mechanisms without changing the behavior of existing programs and with reasonable performance, as indicated by our experimental evaluation.},
}

@inproceedings{Eichberg:2018:Lattice,
  acronym = {SOAP},
  author = {Eichberg, Michael and Kübler, Florian and Helm, Dominik and Reif, Michael and Salvaneschi, Guido and Mezini, Mira},
  title = {Lattice Based Modularization of Static Analyses},
  booktitle = {Companion Proceedings for the ISSTA/ECOOP 2018 Workshops},
  series = {ISSTA/ECOOP Companion '18},
  year = {2018},
  month = jul,
  numpages = {6},
  pages = {113--118},
  location = {Amsterdam, Netherlands},
  publisher = {ACM},
  address = {New York, NY, USA},
  isbn = {978-1-4503-5939-9},
  doi = {10.1145/3236454.3236509},
  keywords = {Modularization, Static Analysis Framework, Lattice, Abstract Interpretation},
  abstract = {Static analyses which compute conceptually independent information, e.g., class immutability or method purity are typically developed as standalone, closed analyses. Complementary information that could improve the analyses is either ignored by making a sound over-approximation or it is also computed by the analyses, but at a rudimentary level. For example, an immutability analysis requires field mutability information, alias/escape information, and information about the concurrent behavior of methods to correctly classify classes like java.lang.String or java.util.BigDecimal. As a result, without properly supporting the integration of independently developed, mutually benefiting analysis, many analyses will not correctly classify relevant entities.We propose to use explicitly reified lattices that encode the information about a source code element's properties (e.g., a method's purity or a class' immutability) as the sole interface between mutually dependent analyses. This enables the composition of multiple analyses. Our case study shows that using such an approach enables highly scalable, lightweight implementations of modularized static analyses.},
}

@inproceedings{Weisenburger:2018:Static,
  acronym = {FTfJP},
  projects = {ScalaLoci},
  file = {papers/2018_Static-Latency-Tracking-with-Placement-Types.pdf},
  author = {Weisenburger, Pascal and Reinhard, Tobias and Salvaneschi, Guido},
  title = {Static Latency Tracking with Placement Types},
  booktitle = {Companion Proceedings for the ISSTA/ECOOP 2018 Workshops},
  series = {ISSTA/ECOOP Companion '18},
  year = {2018},
  month = jul,
  numpages = {3},
  pages = {34--36},
  location = {Amsterdam, Netherlands},
  publisher = {ACM},
  address = {New York, NY, USA},
  isbn = {978-1-4503-5939-9},
  doi = {10.1145/3236454.3236486},
  abstract = {Large-scale distributed applications, e.g., in geodistributed data centers, pose a performance challenge to developers which need to take high cross-data-center latency communication cost into account. We present a preliminary investigation of a type system that tracks latency and makes the cost of remote calls explicit, raising developers' awareness of communication overhead.},
}

@article{Bračevac:2018:Versatile,
  acronym = {ICFP},
  file = {papers/2018-Versatile-event-correlation-with-algebraic-effects.pdf},
  author = {Bračevac, Oliver and Amin, Nada and Salvaneschi, Guido and Erdweg, Sebastian and Eugster, Patrick and Mezini, Mira},
  title = {Versatile Event Correlation with Algebraic Effects},
  year = {2018},
  month = jul,
  issue_date = {September 2018},
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {2},
  number = {ICFP},
  articleno = {67},
  numpages = {31},
  pages = {67:1--67:31},
  location = {St. Louis, MO, USA},
  publisher = {ACM},
  address = {New York, NY, USA},
  issn = {2475-1421},
  doi = {10.1145/3236762},
  keywords = {Joins, Koka, Complex Event Processing, Asynchrony, Algebraic Effect Handlers, Event Correlation, Multicore OCaml},
  abstract = {We present the first language design to uniformly express variants of n-way joins over asynchronous event streams from different domains, e.g., stream-relational algebra, event processing, reactive and concurrent programming. We model asynchronous reactive programs and joins in direct style, on top of algebraic effects and handlers. Effect handlers act as modular interpreters of event notifications, enabling fine-grained control abstractions and customizable event matching. Join variants can be considered as cartesian product computations with ``degenerate'' control flow, such that unnecessary tuples are not materialized a priori. Based on this computational interpretation, we decompose joins into a generic, naïve enumeration procedure of the cartesian product, plus variant-specific extensions, represented in terms of user-supplied effect handlers. Our microbenchmarks validate that this extensible design avoids needless materialization. Alongside a formal semantics for joining and prototypes in Koka and multicore OCaml, we contribute a systematic comparison of the covered domains and features.},
}

@inproceedings{Graubner:2018:Multimodal,
  acronym = {DEBS},
  author = {Graubner, Pablo and Thelen, Christoph and Körber, Michael and Sterz, Artur and Salvaneschi, Guido and Mezini, Mira and Seeger, Bernhard and Freisleben, Bernd},
  title = {Multimodal Complex Event Processing on Mobile Devices},
  booktitle = {Proceedings of the 12th ACM International Conference on Distributed and Event-Based Systems},
  series = {DEBS '18},
  year = {2018},
  month = jun,
  numpages = {12},
  pages = {112--123},
  location = {Hamilton, New Zealand},
  publisher = {ACM},
  address = {New York, NY, USA},
  isbn = {978-1-4503-5782-1},
  doi = {10.1145/3210284.3210289},
  keywords = {Edge/Fog Computing, Mobile Device, Complex Event Processing},
  abstract = {Mobile devices are increasingly being used in edge and fog computing environments to process contextual data collected by sensors. Although complex event processing (CEP) is a suitable approach for realizing context-aware services on mobile devices in these environments, existing mobile CEP engines do not leverage the full potential of modern mobile hardware/software architectures. In this paper, we present multimodal CEP, a novel approach to process streams of events on-device in user space (user mode), in the operating system (kernel mode), on the Wi-Fi chip (Wi-Fi mode), and/or on a sensor hub (hub mode), providing significant improvements in terms of power consumption and throughput. Multimodal CEP automatically breaks up CEP queries and selects the most adequate execution mode for the involved CEP operators. Filter, aggregation, and correlation operators can be expressed in a high-level language without requiring system-level domain-specific knowledge. Multimodal CEP enables developers to efficiently detect user activities, collect environmental conditions, or interpret operating system and network events. Furthermore, it facilitates novel context-aware services, demonstrated by a use case for gathering and analyzing mobility data by Wi-Fi probe request tracking.},
}

@inproceedings{Luthra:2018:TCEP,
  acronym = {DEBS},
  file = {papers/2018_TCEP-Adapting-to-Dynamic-User-Environments-by-Enabling-Transitions-between-Operator-Placement-Mechanisms.pdf},
  author = {Luthra, Manisha and Koldehofe, Boris and Weisenburger, Pascal and Salvaneschi, Guido and Arif, Raheel},
  title = {{TCEP}: Adapting to Dynamic User Environments by Enabling Transitions between Operator Placement Mechanisms},
  booktitle = {Proceedings of the 12th ACM International Conference on Distributed and Event-Based Systems},
  series = {DEBS '18},
  year = {2018},
  month = jun,
  numpages = {12},
  pages = {136--147},
  location = {Hamilton, New Zealand},
  publisher = {ACM},
  address = {New York, NY, USA},
  isbn = {978-1-4503-5782-1},
  doi = {10.1145/3210284.3210292},
  keywords = {Stream Processing, Adaptation, Operator Placement, Migration, Internet of Things, Complex Event Processing, Transitions},
  abstract = {Operator placement has a profound impact on the performance of a distributed complex event processing system (DCEP). Since the behavior of a placement mechanism strongly depends on its environment; a single placement mechanism is often not enough to fulfill stringent performance requirements under environmental changes. In this paper, we show how DCEP can benefit from the adaptive use of multiple placement mechanisms. We propose TCEP, a DCEP system to integrate multiple placement mechanisms. By enabling transitions, TCEP can seamlessly exchange distinct operator mechanisms at runtime. We make two main contributions that are highly important for a cost-efficient transition: i) a transition strategy for efficiently scheduling state migrations and ii) a lightweight learning algorithm to adaptively select an appropriate placement mechanism as a consequence of a transition. Our evaluations for important decentralized placement mechanisms in the context of an IoT scenario show that transitions can better fulfill QoS demands in a dynamic environment. Thereby efficient scheduling of state migrations can help to faster complete transitions by up to 94~%.},
}

@article{Margara:2018:Semantics,
  acronym = {TSE},
  author = {Margara, Alessandro and Salvaneschi, Guido},
  title = {On the Semantics of Distributed Reactive Programming: The Cost of Consistency},
  year = {2018},
  month = may,
  journal = {IEEE Transactions on Software Engineering},
  volume = {44},
  number = {7},
  numpages = {23},
  pages = {689--711},
  publisher = {IEEE Press},
  address = {Piscataway, NJ, USA},
  issn = {0098-5589},
  doi = {10.1109/TSE.2018.2833109},
  keywords = {Distributed Reactive Programming, Consistency Guarantees, Reactive Programming Middleware, DREAM},
  abstract = {The reactive programming paradigm aims to simplify the development of reactive systems. It provides abstractions to define time-changing values that are automatically updated by the runtime according to their dependencies. The benefits of reactive programming in distributed settings have been recognized for long. Yet, existing solutions for distributed reactive programming enforce the same semantics as in single processes, introducing communication and synchronization costs that hamper scalability. Establishing suitable abstractions for distributed reactive programming demands for a deeper investigation of the semantics of change propagation. This paper takes a foundational approach and defines precise propagation semantics in terms of consistency guarantees that constrain the order and isolation of value updates. We study the benefits and costs of these consistency guarantees both theoretically and empirically, using case studies and synthetic benchmarks. We show that different applications require different levels of consistency and that manually implementing the required level on a middleware that provides a lower one annuls the abstraction improvements of reactive programming. This motivates a framework that enables the developers to select the best trade-off between consistency and overhead for the problem at hand. To this end, we present DREAM, a distributed reactive programming middleware with flexible consistency guarantees.},
}

@inproceedings{Mogk:2018:Reactive,
  acronym = {PX},
  projects = {REScala},
  author = {Mogk, Ragnar and Salvaneschi, Guido and Mezini, Mira},
  title = {Reactive Programming Experience with {REScala}},
  booktitle = {Companion Proceedings for the 2nd International Conference on Art, Science, and Engineering of Programming},
  series = {‹Programming› Companion '18},
  year = {2018},
  month = apr,
  numpages = {8},
  pages = {105--112},
  location = {Nice, France},
  publisher = {ACM},
  address = {New York, NY, USA},
  isbn = {978-1-4503-5513-1},
  doi = {10.1145/3191697.3214337},
  keywords = {Programming Experience, Reactive Programming, Language Design, Case Studies, Programming Paradigms},
  abstract = {Reactive programming is a recent programming paradigm that specifically targets reactive applications. Over the years, a number of reactive languages have been proposed, with different combinations of features, and various target domains. Unfortunately, there is a lack of knowledge about the experience of developing software applications with reactive languages. As a result, a number of design choices in reactive programming languages remain disconnected from experience and the applicability of reactive programming to various domains remains unclear. To bridge this gap, we report on our experience of developing reactive applications as well as teaching reactive programming in REScala, which we collected over several years of research and practice.},
}

@inproceedings{Eichholz:2018:Safe,
  acronym = {PASS},
  author = {Eichholz, Matthias and Salvaneschi, Guido and Mezini, Mira},
  title = {Towards Safe Modular Composition of Network Functions},
  booktitle = {Companion Proceedings for the 2nd International Conference on Art, Science, and Engineering of Programming},
  series = {‹Programming› Companion '18},
  year = {2018},
  month = apr,
  numpages = {6},
  pages = {81--86},
  location = {Nice, France},
  publisher = {ACM},
  address = {New York, NY, USA},
  isbn = {978-1-4503-5513-1},
  doi = {10.1145/3191697.3213804},
  keywords = {Network-Functions, Modularity, Software-Defined Networks},
  abstract = {Network Function Virtualization (NFV) aims to overcome the limitations of hardware middleboxes by moving network functions to software. Ultimately, this approach enables deployment into virtualized environments with higher flexibility, reducing deployment time and costs. In common industrial practice, multiple smaller network functions are often chained together into service function chains. Yet, service function chains are extremely fragile, lacking basic guarantees on correct composition and dependency reasoning. In this position paper, we propose a roadmap towards language abstractions that address this issue. We introduce the problems with current service function chaining technology and present the research program we envision.},
}

@article{Salvaneschi:2017:Positive,
  acronym = {TSE},
  projects = {REScala},
  file = {papers/2017_On-the-Positive-Effect-of-Reactive-Programming-on-Software-Comprehension-An-Empirical-Study.pdf},
  author = {Salvaneschi, Guido and Proksch, Sebastian and Amann, Sven and Nadi, Sarah and Mezini, Mira},
  title = {On the Positive Effect of Reactive Programming on Software Comprehension: An Empirical Study},
  year = {2017},
  month = dec,
  issue_date = {December 2017},
  journal = {IEEE Transactions on Software Engineering},
  volume = {43},
  number = {12},
  numpages = {19},
  pages = {1125--1143},
  publisher = {IEEE Press},
  address = {Piscataway, NJ, USA},
  issn = {0098-5589},
  doi = {10.1109/TSE.2017.2655524},
  keywords = {Reactive Programming, Empirical Study, Controlled Experiment, Software Comprehension},
  abstract = {Starting from the first investigations with strictly functional languages, reactive programming has been proposed as the programming paradigm for reactive applications. Over the years, researchers have enriched reactive languages with more powerful abstractions, embedded these abstractions into mainstream languages---including object-oriented languages---and applied reactive programming to several domains, such as GUIs, animations, Web applications, robotics, and sensor networks. However, an important assumption behind this line of research is that, beside other claimed advantages, reactive programming makes a wide class of otherwise cumbersome applications more comprehensible. This claim has never been evaluated. In this paper, we present the first empirical study that evaluates the effect of reactive programming on comprehension. The study involves&nbsp;127 subjects and compares reactive programming to the traditional object-oriented style with the Observer design pattern. Our findings show that program comprehension is significantly enhanced by the reactive-programming paradigm---a result that suggests to further develop research in this field.},
}

@inproceedings{Margara:2017:Consistency,
  acronym = {FTFJP},
  projects = {ConSysT},
  file = {papers/2017_Consistency-Types-for-Safe-and-Efficient-Distributed-Programming.pdf},
  author = {Margara, Alessandro and Salvaneschi, Guido},
  title = {Consistency Types for Safe and Efficient Distributed Programming},
  booktitle = {Proceedings of the 19th Workshop on Formal Techniques for Java-like Programs},
  series = {FTFJP '17},
  year = {2017},
  month = jun,
  articleno = {8},
  numpages = {2},
  pages = {8:1--8:2},
  location = {Barcelona, Spain},
  publisher = {ACM},
  address = {New York, NY, USA},
  isbn = {978-1-4503-5098-3},
  doi = {10.1145/3103111.3104044},
  abstract = {Consistency is a long standing problem in distributed systems. Low consistency levels are considered a necessity for scalability. High consistency is required for critical tasks such as payment and identification. Modern (geo-)distributed systems rely on the data propagation mechanisms and consistency guarantees of the distributed data store they build upon, which makes the implementation of a system that mixes different levels of consistency complex and error prone. In this paper we present preliminary work on ConSysT, a programming language that supports heterogeneous consistency specifications at the type level. In ConSysT, developers assign consistency levels directly to the data and the type system ensures the correct behavior of the application even with computations that mix data at multiple consistency levels. Our vision is that the ConSysT runtime automatically determines the most efficient mechanism to achieve the desired level of consistency among those offered by the underlying data store.},
}

@inproceedings{Weisenburger:2017:QualityAware,
  acronym = {SEAMS},
  file = {papers/2017_Quality-aware-runtime-adaptation-in-complex-event-processing.pdf},
  author = {Weisenburger, Pascal and Luthra, Manisha and Koldehofe, Boris and Salvaneschi, Guido},
  title = {Quality-Aware Runtime Adaptation in Complex Event Processing},
  booktitle = {Proceedings of the 12th International Symposium on Software Engineering for Adaptive and Self-Managing Systems},
  series = {SEAMS '17},
  year = {2017},
  month = may,
  numpages = {12},
  pages = {140--151},
  location = {Buenos Aires, Argentina},
  publisher = {IEEE Press},
  address = {Piscataway, NJ, USA},
  isbn = {978-1-5386-1550-8},
  doi = {10.1109/SEAMS.2017.10},
  abstract = {Complex event processing (CEP) is a fundamental paradigm for a software system to self-adapt to environmental changes. CEP provides efficient means to detect (complex) events corresponding to environmental changes by performing a real-time analysis on many, possibly heterogeneous, data sources. The way current CEP systems detect events is determined at design time without accounting for dynamic changes of the environment monitored by the CEP system. This can lead to situations where the performance, quality and reliability of event detection significantly drop (e.g., due to mobility) since initial assumptions of the environment are violated or stated too general. In this paper, we propose AdaptiveCEP, a CEP system that is able to self-adapt to detected changes in environmental conditions. We propose a CEP query language that allows specifying changes in the behavior of the CEP system and its mechanisms in detecting events dependent on environmental conditions. This way, AdaptiveCEP can select the best-suited configurations for given quality demands. In our evaluation, we show by means of a reference concept how the flexibility exposed by the query language helps to achieve significant performance gains.},
}

@inproceedings{Weisenburger:2016:Multitier,
  acronym = {SPLASH DS},
  projects = {ScalaLoci},
  file = {papers/2016_Multitier-Reactive-Abstractions.pdf},
  author = {Weisenburger, Pascal},
  title = {Multitier Reactive Abstractions},
  booktitle = {Companion Proceedings of the 2016 ACM SIGPLAN International Conference on Systems, Programming, Languages and Applications: Software for Humanity},
  series = {SPLASH Companion '16},
  year = {2016},
  month = oct,
  numpages = {3},
  pages = {18--20},
  location = {Amsterdam, Netherlands},
  publisher = {ACM},
  address = {New York, NY, USA},
  isbn = {978-1-4503-4437-1},
  doi = {10.1145/2984043.2984051},
  keywords = {Distributed Programming, Reactive Programming},
  abstract = {Distributed applications are traditionally developed using separate modules for each component in the distributed system, which can even be written in different programming languages. Those modules react on events such as user input, which are produced by other modules, and may in turn produce new events to be handled by different modules. Thus, most distributed applications are reactive in nature. Distributed event-based data flow makes it is hard to reason about the system and therefore makes the development of distributed systems challenging. In this paper, we present language abstractions for distributed reactive programming easing the development of such applications and supporting various distributed architectures.},
}

@inproceedings{Haller:2016:Reactive,
  acronym = {SCALA},
  file = {papers/2016_Reactive-Async-Expressive-Deterministic-Concurrency.pdf},
  author = {Haller, Philipp and Geries, Simon and Eichberg, Michael and Salvaneschi, Guido},
  title = {{Reactive Async}: Expressive Deterministic Concurrency},
  booktitle = {Proceedings of the 2016 7th ACM SIGPLAN Symposium on Scala},
  series = {SCALA '16},
  year = {2016},
  month = oct,
  numpages = {10},
  pages = {11--20},
  location = {Amsterdam, Netherlands},
  publisher = {ACM},
  address = {New York, NY, USA},
  isbn = {978-1-4503-4648-1},
  doi = {10.1145/2998392.2998396},
  keywords = {Concurrent Programming, Asynchronous Programming, Static Analysis, Deterministic Concurrency, Scala},
  abstract = {Concurrent programming is infamous for its difficulty. An important source of difficulty is non-determinism, stemming from unpredictable interleavings of concurrent activities. Futures and promises are widely-used abstractions that help designing deterministic concurrent programs, although this property cannot be guaranteed statically in mainstream programming languages. Deterministic-by-construction concurrent programming models avoid this issue, but they typically restrict expressiveness in important ways. This paper introduces a concurrent programming model, Reactive Async, which decouples concurrent computations using so-called cells, shared locations which generalize futures as well as recent deterministic abstractions such as LVars. Compared to previously proposed programming models Reactive Async provides (a) a fallback mechanism for the case where no computation ever computes the value of a given cell, and (b) explicit and optimized handling of cyclic dependencies. We present a complete implementation of the Reactive Async programming model as a library in Scala. Finally, the paper reports on a case study applying Reactive Async to static analyses of JVM bytecode based on the Opal framework.},
}

@inproceedings{Hauck:2016:SecureScala,
  acronym = {SCALA},
  file = {papers/2016_SecureScala-Scala-Embedding-of-Secure-Computations.pdf},
  author = {Hauck, Markus and Savvides, Savvas and Eugster, Patrick and Mezini, Mira and Salvaneschi, Guido},
  title = {{SecureScala}: Scala Embedding of Secure Computations},
  booktitle = {Proceedings of the 2016 7th ACM SIGPLAN Symposium on Scala},
  series = {SCALA '16},
  year = {2016},
  month = oct,
  numpages = {10},
  pages = {75--84},
  location = {Amsterdam, Netherlands},
  publisher = {ACM},
  address = {New York, NY, USA},
  isbn = {978-1-4503-4648-1},
  doi = {10.1145/2998392.2998403},
  keywords = {Secure Computation, Domain-Specific Language},
  abstract = {Cloud computing offers an attractive and cost-efficient computing platform and hence it has been widely adopted by the industry and the government. At the same time, cloud computing poses a serious security challenge because sensitive data must often be outsourced to third party entities that can access the data and perform computations on them. Partial homomorphic encryption is promising for secure computation, since it allows programs to be executed over encrypted data. Despite advances in cryptographic techniques have improved the expressivity of such programs, integration with mainstream languages has seen little progress. To this end, we present SecureScala, a domain-specific language in Scala that allows expressing secure programs without requiring any cryptographic knowledge. SecureScala is based on a novel combination of free monads and free applicative functors and supports parallel execution and static analyzability. We evaluate our approach through several case studies, demonstrate its expressivity, and show that it incurs in limited performance overhead.},
}

@inproceedings{Salvaneschi:2016:Languages,
  acronym = {PLATEAU},
  projects = {REScala},
  file = {papers/2016_What-do-we-really-know-about-data-flow-languages.pdf},
  author = {Salvaneschi, Guido},
  title = {What Do We Really Know about Data Flow Languages?},
  booktitle = {Proceedings of the 7th International Workshop on Evaluation and Usability of Programming Languages and Tools},
  series = {PLATEAU '16},
  year = {2016},
  month = oct,
  numpages = {2},
  pages = {30--31},
  location = {Amsterdam, Netherlands},
  publisher = {ACM},
  address = {New York, NY, USA},
  isbn = {978-1-4503-4638-2},
  doi = {10.1145/3001878.3001884},
  keywords = {Controlled Experiment, Reactive Programming, Data Flow Languages},
  abstract = {Over the last years, a number of languages based on data flow abstractions have been proposed in different important areas including Big Data, stream processing, reactive programming, real time analytics. While there is a general agreement that the data flow style simplifies the access to such complex systems compared to low level imperative APIs, this design has been substantiated by little evidence. In this paper, we advocate a systematic investigation of the design principles of data flow languages and suggest important research questions that urge to be addressed.},
}

@inproceedings{Zhang:2016:Accepting,
  acronym = {PLDI},
  author = {Zhang, Yizhou and Salvaneschi, Guido and Beightol, Quinn and Liskov, Barbara and Myers, Andrew C.},
  title = {Accepting Blame for Safe Tunneled Exceptions},
  booktitle = {Proceedings of the 37th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  series = {PLDI '16},
  year = {2016},
  month = jun,
  numpages = {15},
  pages = {281--295},
  location = {Santa Barbara, CA, USA},
  publisher = {ACM},
  address = {New York, NY, USA},
  isbn = {978-1-4503-4261-2},
  doi = {10.1145/2908080.2908086},
  keywords = {Genus, Exception Tunneling, Exception Handling},
  abstract = {Unhandled exceptions crash programs, so a compile-time check that exceptions are handled should in principle make software more reliable. But designers of some recent languages have argued that the benefits of statically checked exceptions are not worth the costs. We introduce a new statically checked exception mechanism that addresses the problems with existing checked-exception mechanisms. In particular, it interacts well with higher-order functions and other design patterns. The key insight is that whether an exception should be treated as a "checked" exception is not a property of its type but rather of the context in which the exception propagates. Statically checked exceptions can "tunnel" through code that is oblivious to their presence, but the type system nevertheless checks that these exceptions are handled. Further, exceptions can be tunneled without being accidentally caught, by expanding the space of exception identifiers to identify the exception-handling context. The resulting mechanism is expressive and syntactically light, and can be implemented efficiently. We demonstrate the expressiveness of the mechanism using significant codebases and evaluate its performance. We have implemented this new exception mechanism as part of the new Genus programming language, but the mechanism could equally well be applied to other programming languages.},
}

@inproceedings{Salvaneschi:2016:Debugging,
  acronym = {ICSE},
  projects = {REScala},
  file = {papers/2016_Debugging-for-Reactive-Programming.pdf},
  author = {Salvaneschi, Guido and Mezini, Mira},
  title = {Debugging for Reactive Programming},
  booktitle = {Proceedings of the 38th International Conference on Software Engineering},
  series = {ICSE '16},
  year = {2016},
  month = may,
  numpages = {12},
  pages = {796--807},
  location = {Austin, Texas},
  publisher = {ACM},
  address = {New York, NY, USA},
  isbn = {978-1-4503-3900-1},
  doi = {10.1145/2884781.2884815},
  keywords = {Functional-Reactive Programming, Debugging},
  abstract = {Reactive programming is a recent programming technique that provides dedicated language abstractions for reactive software. Reactive programming relieves developers from manually updating outputs when the inputs of a computation change, it overcomes a number of well-know issues of the Observer design pattern, and it makes programs more comprehensible. Unfortunately, complementing the new paradigm with proper tools is a vastly unexplored area. Hence, as of now, developers can embrace reactive programming only at the cost of a more challenging development process.\par In this paper, we investigate a primary issue in the field: debugging programs in the reactive style. We analyze the problem of debugging reactive programs, show that the reactive style requires a paradigm shift in the concepts needed for debugging, and propose RP Debugging, a methodology for effectively debugging reactive programs. These ideas are implemented in Reactive Inspector, a debugger for reactive programs integrated with the Eclipse Scala IDE. Evaluation based on a controlled experiment shows that RP Debugging outperforms traditional debugging techniques.},
}

@inproceedings{Salvaneschi:2016:Inspector,
  acronym = {ICSE Companion},
  projects = {REScala},
  file = {papers/2016_Debugging-Reactive-Programming-with-Reactive-Inspector.pdf},
  author = {Salvaneschi, Guido and Mezini, Mira},
  title = {Debugging Reactive Programming with Reactive Inspector},
  booktitle = {Companion Proceedings of the 38th International Conference on Software Engineering},
  series = {ICSE Companion '16},
  year = {2016},
  month = may,
  numpages = {3},
  pages = {728--730},
  location = {Austin, Texas},
  publisher = {ACM},
  address = {New York, NY, USA},
  isbn = {978-1-4503-4205-6},
  doi = {10.1145/2889160.2893174},
  keywords = {Debugging, Functional-Reactive Programming},
  abstract = {Reactive programming provides dedicated language abstractions for reactive software, relieving developers from manually updating outputs when the inputs of a computation change. Unfortunately, complementing the new paradigm with proper tools that support coding activities is a vastly unexplored area.\par We investigate a primary issue in the field: debugging programs in the reactive style. We propose RP Debugging, a methodology for effectively debugging reactive programs. These ideas are implemented in Reactive Inspector, a debugger for reactive programs integrated with the Eclipse Scala development environment.},
}

@inproceedings{Bračevac:2016:CPL,
  acronym = {MODULARITY},
  file = {papers/2016_CPL-A-Core-Language-for-Cloud-Computing.pdf},
  author = {Bračevac, Oliver and Erdweg, Sebastian and Salvaneschi, Guido and Mezini, Mira},
  title = {{CPL}: A Core Language for Cloud Computing},
  booktitle = {Proceedings of the 15th International Conference on Modularity},
  series = {MODULARITY '16},
  year = {2016},
  month = mar,
  numpages = {12},
  pages = {94--105},
  location = {Málaga, Spain},
  publisher = {ACM},
  address = {New York, NY, USA},
  isbn = {978-1-4503-3995-7},
  doi = {10.1145/2889443.2889452},
  keywords = {Cloud Computing, Join Calculus, Computation Patterns, Cloud Deployment},
  abstract = {Running distributed applications in the cloud involves deployment. That is, distribution and configuration of application services and middleware infrastructure. The considerable complexity of these tasks resulted in the emergence of declarative JSON-based domain-specific deployment languages to develop deployment programs. However, existing deployment programs unsafely compose artifacts written in different languages, leading to bugs that are hard to detect before run time. Furthermore, deployment languages do not provide extension points for custom implementations of existing cloud services such as application-specific load balancing policies. To address these shortcomings, we propose CPL (Cloud Platform Language), a statically-typed core language for programming both distributed applications as well as their deployment on a cloud platform. In CPL, application services and deployment programs interact through statically typed, extensible interfaces, and an application can trigger further deployment at run time. We provide a formal semantics of CPL and demonstrate that it enables type-safe, composable and extensible libraries of service combinators, such as load balancing and fault tolerance.},
}

@inproceedings{Zhang:2015:Lightweight,
  acronym = {PLDI},
  file = {papers/2015_Lightweight-Flexible-Object-Oriented-Generics.pdf},
  author = {Zhang, Yizhou and Loring, Matthew C. and Salvaneschi, Guido and Liskov, Barbara and Myers, Andrew C.},
  title = {Lightweight, Flexible Object-Oriented Generics},
  booktitle = {Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  series = {PLDI '15},
  year = {2015},
  month = jun,
  numpages = {10},
  pages = {436--445},
  location = {Portland, OR, USA},
  publisher = {ACM},
  address = {New York, NY, USA},
  isbn = {978-1-4503-3468-6},
  doi = {10.1145/2737924.2738008},
  keywords = {Generic Programming, Constraints, Models, Genus},
  abstract = {The support for generic programming in modern object-oriented programming languages is awkward and lacks desirable expressive power. We introduce an expressive genericity mechanism that adds expressive power and strengthens static checking, while remaining lightweight and simple in common use cases. Like type classes and concepts, the mechanism allows existing types to model type constraints retroactively. For expressive power, we expose models as named constructs that can be defined and selected explicitly to witness constraints; in common uses of genericity, however, types implicitly witness constraints without additional programmer effort. Models are integrated into the object-oriented style, with features like model generics, model-dependent types, model enrichment, model multimethods, constraint entailment, model inheritance, and existential quantification further extending expressive power in an object-oriented setting. We introduce the new genericity features and show that common generic programming idioms, including current generic libraries, can be expressed more precisely and concisely. The static semantics of the mechanism and a proof of a key decidability property can be found in an associated technical report.},
}

@article{Salvaneschi:2015:ContextErlang,
  acronym = {SCP},
  file = {papers/2015_ContextErlang-A-language-for-distributed-context-aware-self-adaptive-applications.pdf},
  author = {Salvaneschi, Guido and Ghezzi, Carlo and Pradella, Matteo},
  title = {{ContextErlang}},
  year = {2015},
  month = may,
  issue_date = {May 2015},
  journal = {Science of Computer Programming},
  volume = {102},
  number = {C},
  numpages = {24},
  pages = {20--43},
  publisher = {Elsevier North-Holland, Inc.},
  address = {Amsterdam, Netherlands},
  issn = {0167-6423},
  doi = {10.1016/j.scico.2014.11.016},
  keywords = {Context, Context-Oriented Programming, Distribution, Concurrency, Self-Adaptive Software},
  abstract = {Self-adaptive software modifies its behavior at run time to satisfy changing requirements in a dynamic environment. Context-oriented programming (COP) has been recently proposed as a specialized programming paradigm for context-aware and adaptive systems. COP mostly focuses on run time adaptation of the application's behavior by supporting modular descriptions of behavioral variations. However, self-adaptive applications must satisfy additional requirements, such as distribution and concurrency, support for unforeseen changes and enforcement of correct behavior in the presence of dynamic change. Addressing these issues at the language level requires a holistic design that covers all aspects and takes into account the possibly cumbersome interaction of those features, for example concurrency and dynamic change.\par We present ContextErlang, a COP programming language in which adaptive abstractions are seamlessly integrated with distribution and concurrency. We define ContextErlang's formal semantics, validated through an executable prototype, and we show how it supports formal proofs that the language design ensures satisfaction of certain safety requirements. We provide empirical evidence that ContextErlang is an effective solution through case studies and a performance assessment. We also show how the same design principles that lead to the development of ContextErlang can be followed to systematically design contextual extensions of other languages. A concrete example is presented concerning ContextScala.},
}

@inproceedings{Salvaneschi:2015:Reactive,
  acronym = {ICSE},
  projects = {REScala},
  author = {Salvaneschi, Guido and Margara, Alessandro and Tamburrelli, Giordano},
  title = {Reactive Programming: A Walkthrough},
  booktitle = {Proceedings of the 37th International Conference on Software Engineering},
  series = {ICSE '15},
  year = {2015},
  month = may,
  numpages = {2},
  pages = {953--954},
  location = {Florence, Italy},
  publisher = {IEEE Press},
  address = {Piscataway, NJ, USA},
  doi = {10.1109/ICSE.2015.303},
  abstract = {Over the last few years, Reactive Programming has emerged as the trend to support the development of reactive software through dedicated programming abstractions. Reactive Programming has been increasingly investigated in the programming languages community and it is now gaining the interest of practitioners. Conversely, it has received so far less attention from the software engineering community.\par This technical briefing bridges this gap through an accurate overview of Reactive Programming, discussing the available frameworks and outlining open research challenges with an emphasis on cross-field research opportunities.},
}

@inbook{Salvaneschi:2014:Reactive,
  projects = {REScala},
  file = {papers/2014_Towards-Reactive-Programming-for-Object-Oriented-Applications.pdf},
  author = {Salvaneschi, Guido and Mezini, Mira},
  title = {Towards Reactive Programming for Object-Oriented Applications},
  booktitle = {Transactions on Aspect-Oriented Software Development XI},
  series = {Lecture Notes in Computer Science},
  year = {2014},
  volume = {8400},
  pages = {227--261},
  editor = {Chiba, Shigeru and Tanter, Éric and Bodden, Eric and Maoz, Shahar and Kienzle, Jörg},
  publisher = {Springer-Verlag},
  address = {Berlin/Heidelberg, Germany},
  isbn = {978-3-642-55098-0},
  doi = {10.1007/978-3-642-55099-7_7},
  keywords = {Reactive Programming, Functional-Reactive Programming, Object-Oriented Programming, Incremental Computation},
  abstract = {Reactive applications are difficult to implement. Traditional solutions based on event systems and the Observer pattern have a number of inconveniences, but programmers bear them in return for the benefits of OO design. On the other hand, reactive approaches based on automatic updates of dependencies -- like functional reactive programming and dataflow languages -- provide undoubted advantages but do not fit well with mutable objects.},
}

@inproceedings{Salvaneschi:2014:Empirical,
  acronym = {FSE},
  projects = {REScala},
  file = {papers/2014_An-Empirical-Study-on-Program-Comprehension-with-Reactive-Programming.pdf},
  author = {Salvaneschi, Guido and Amann, Sven and Proksch, Sebastian and Mezini, Mira},
  title = {An Empirical Study on Program Comprehension with Reactive Programming},
  booktitle = {Proceedings of the 22nd ACM SIGSOFT International Symposium on Foundations of Software Engineering},
  series = {FSE '14},
  year = {2014},
  month = nov,
  numpages = {12},
  pages = {564--575},
  location = {Hong Kong, China},
  publisher = {ACM},
  address = {New York, NY, USA},
  isbn = {978-1-4503-3056-5},
  doi = {10.1145/2635868.2635895},
  keywords = {Reactive Programming, Empirical Study, Controlled Experiment},
  abstract = {Starting from the first investigations with strictly functional languages, reactive programming has been proposed as THE programming paradigm for reactive applications. The advantages of designs based on this style over designs based on the Observer design pattern have been studied for a long time. Over the years, researchers have enriched reactive languages with more powerful abstractions, embedded these abstractions into mainstream languages -- including object-oriented languages -- and applied reactive programming to several domains, like GUIs, animations, Web applications, robotics, and sensor networks. However, an important assumption behind this line of research -- that, beside other advantages, reactive programming makes a wide class of otherwise cumbersome applications more comprehensible -- has never been evaluated. In this paper, we present the design and the results of the first empirical study that evaluates the effect of reactive programming on comprehensibility compared to the traditional object-oriented style with the Observer design pattern. Results confirm the conjecture that comprehensibility is enhanced by reactive programming. In the experiment, the reactive programming group significantly outperforms the other group.},
}

@inproceedings{Drechsler:2014:Distributed,
  acronym = {OOPSLA},
  projects = {REScala},
  file = {papers/2014_Distributed_REScala_An_Update_Algorithm_for_Distributed_Reactive_Programming.pdf},
  author = {Drechsler, Joscha and Salvaneschi, Guido and Mogk, Ragnar and Mezini, Mira},
  title = {Distributed {REScala}: An Update Algorithm for Distributed Reactive Programming},
  booktitle = {Proceedings of the 2014 ACM International Conference on Object-oriented Programming, Systems, Languages, and Applications},
  series = {OOPSLA '14},
  year = {2014},
  month = oct,
  numpages = {16},
  pages = {361--376},
  location = {Portland, OR, USA},
  publisher = {ACM},
  address = {New York, NY, USA},
  isbn = {978-1-4503-2585-1},
  doi = {10.1145/2660193.2660240},
  keywords = {Distributed Programming, Scala, Reactive Programming},
  abstract = {Reactive programming improves the design of reactive applications by relocating the logic for managing dependencies between dependent values away from the application logic to the language implementation. Many distributed applications are reactive. Yet, existing change propagation algorithms are not suitable in a distributed setting.\par We propose Distributed REScala, a reactive language with a change propagation algorithm that works without centralized knowledge about the topology of the dependency structure among reactive values and avoids unnecessary propagation of changes, while retaining safety guarantees (glitch freedom). Distributed REScala enables distributed reactive programming, bringing the benefits of reactive programming to distributed applications. We demonstrate the enabled design improvements by a case study. We also empirically evaluate the performance of our algorithm in comparison to other algorithms in a simulated distributed setting.},
}

@inproceedings{Mitschke:2014:i3QL,
  acronym = {OOPSLA},
  file = {papers/2014_i3QL_Language-Integrated_Live_Data_Views.pdf},
  author = {Mitschke, Ralf and Erdweg, Sebastian and Köhler, Mirko and Mezini, Mira and Salvaneschi, Guido},
  title = {{i3QL}: Language-Integrated Live Data Views},
  booktitle = {Proceedings of the 2014 ACM International Conference on Object-oriented Programming, Systems, Languages, and Applications},
  series = {OOPSLA '14},
  year = {2014},
  month = oct,
  numpages = {16},
  pages = {417--432},
  location = {Portland, OR, USA},
  publisher = {ACM},
  address = {New York, NY, USA},
  isbn = {978-1-4503-2585-1},
  doi = {10.1145/2660193.2660242},
  keywords = {Reactive Programming, Scala, Incremental Computation},
  abstract = {An incremental computation updates its result based on a change to its input, which is often an order of magnitude faster than a recomputation from scratch. In particular, incrementalization can make expensive computations feasible for settings that require short feedback cycles, such as interactive systems, IDEs, or (soft) real-time systems.\par This paper presents i3QL, a general-purpose programming language for specifying incremental computations. i3QL provides a declarative SQL-like syntax and is based on incremental versions of operators from relational algebra, enriched with support for general recursion. We integrated i3QL into Scala as a library, which enables programmers to use regular Scala code for non-incremental subcomputations of an i3QL query and to easily integrate incremental computations into larger software projects. To improve performance, i3QL optimizes user-defined queries by applying algebraic laws and partial evaluation. We describe the design and implementation of i3QL and its optimizations, demonstrate its applicability, and evaluate its performance.},
}

@article{Salvaneschi:2014:Programming,
  acronym = {Software},
  file = {papers/2014_Programming_with_Implicit_Flows.pdf},
  author = {Salvaneschi, Guido and Eugster, Patrick and Mezini, Mira},
  title = {Programming with Implicit Flows},
  year = {2014},
  month = jun,
  journal = {IEEE Software},
  volume = {31},
  number = {5},
  pages = {52--59},
  issn = {0740-7459},
  doi = {10.1109/MS.2014.101},
  abstract = {Modern software differs significantly from traditional computer applications that mostly process reasonably small amounts of static input data-sets in batch mode. Modern software increasingly processes massive amounts of data, whereby it is also often the case that new input data is produced and/or existing data is modified on the fly. Consequently, programming models that facilitate the development of such software are emerging. What characterizes them is that data, respectively changes thereof, implicitly flow through computation modules. The software engineer declaratively defines computations as compositions of other computations without explicitly modeling how data should flow along dependency relations between data producer and data consumer modules, letting the runtime to automatically manage and optimize data flows.},
}

@inproceedings{Margara:2014:DREAM,
  acronym = {DEBS},
  projects = {ConSysT},
  file = {papers/2014_We-Have-a-DREAM-Distributed-Reactive-Programming-with-Consistency-Guarantees.pdf},
  author = {Margara, Alessandro and Salvaneschi, Guido},
  title = {We Have a {DREAM}: Distributed Reactive Programming with Consistency Guarantees},
  booktitle = {Proceedings of the 8th ACM International Conference on Distributed Event-Based Systems},
  series = {DEBS '14},
  year = {2014},
  month = may,
  numpages = {12},
  pages = {142--153},
  location = {Mumbai, India},
  publisher = {ACM},
  address = {New York, NY, USA},
  isbn = {978-1-4503-2737-4},
  doi = {10.1145/2611286.2611290},
  keywords = {Distributed Reactive Programming, Event-Based Middleware, Glitch-Freedom, Consistency Guarantees, DREAM},
  abstract = {The reactive programming paradigm has been proposed to simplify the development of reactive systems. It relies on programming primitives to express dependencies between data items and on runtime/middleware support for automated propagation of changes. Despite this paradigm is receiving increasing attention, defining the precise semantics and the consistency guarantees for reactive programming in distributed environments is an open research problem.\par This paper targets such problem by studying the consistency guarantees for the propagation of changes in a distributed reactive system. In particular, it introduces three propagation semantics, namely causal, glitch free, and atomic, providing different trade-offs between costs and guarantees. Furthermore, it describes how these semantics are concretely implemented in a Distributed REActice Middleware (DREAM), which exploits a distributed event-based dispatching system to propagate changes.\par We compare the performance of DREAM in a wide range of scenarios. This allows us to study the overhead introduced by the different semantics in terms of network traffic and propagation delay and to assess the efficiency of DREAM in supporting distributed reactive systems.},
}

@inproceedings{VanHam:2014:JEScala,
  acronym = {MODULARITY},
  projects = {REScala},
  file = {papers/2014_JEScala-Modular-Coordination-with-Declarative-Events-and-Joins.pdf},
  author = {Van Ham, Jurgen M. and Salvaneschi, Guido and Mezini, Mira and Noyé, Jacques},
  title = {{JEScala}: Modular Coordination with Declarative Events and Joins},
  booktitle = {Proceedings of the 13th International Conference on Modularity},
  series = {MODULARITY '14},
  year = {2014},
  month = apr,
  numpages = {12},
  pages = {205--216},
  location = {Lugano, Switzerland},
  publisher = {ACM},
  address = {New York, NY, USA},
  isbn = {978-1-4503-2772-5},
  doi = {10.1145/2577080.2577082},
  keywords = {Concurrency, Join Patterns, Scala, Event-Driven Programming},
  abstract = {Advanced concurrency abstractions overcome the drawbacks of low-level techniques such as locks and monitors, freeing programmers that implement concurrent applications from the burden of concentrating on low-level details. However, with current approaches the coordination logic involved in complex coordination schemas is fragmented into several pieces including join patterns, data emissions triggered in different places of the application, and the application logic that implicitly creates dependencies among communication channels, hence indirectly among join patterns. We present JEScala, a language that captures coordination schemas in a more expressive and modular way by leveraging a seamless integration of an advanced event system with join abstractions. We validate our approach with case studies and provide a first performance assessment.},
}

@inproceedings{Salvaneschi:2014:REScala,
  acronym = {MODULARITY},
  projects = {REScala},
  file = {papers/2014_REScala-Bridging-The-Gap-Between-Object-Oriented-And-Functional-Style-In-Reactive-Applications.pdf},
  author = {Salvaneschi, Guido and Hintz, Gerold and Mezini, Mira},
  title = {{REScala}: Bridging between Object-Oriented and Functional Style in Reactive Applications},
  booktitle = {Proceedings of the 13th International Conference on Modularity},
  series = {MODULARITY '14},
  year = {2014},
  month = apr,
  numpages = {12},
  pages = {25--36},
  location = {Lugano, Switzerland},
  publisher = {ACM},
  address = {New York, NY, USA},
  isbn = {978-1-4503-2772-5},
  doi = {10.1145/2577080.2577083},
  keywords = {Scala, Event-Driven Programming, Functional-Reactive Programming},
  abstract = {Traditionally, object-oriented software adopts the Observer pattern to implement reactive behavior. Its drawbacks are well-documented and two families of alternative approaches have been proposed, extending object-oriented languages with concepts from functional reactive and dataflow programming, respectively event-driven programming. The former hardly escape the functional setting; the latter do not achieve the declarativeness of more functional approaches.\par In this paper, we present REScala, a reactive language which integrates concepts from event-based and functional-reactive programming into the object-oriented world. REScala supports the development of reactive applications by fostering a functional declarative style which complements the advantages of object-oriented design.},
}

@misc{Margara:2013:Ways,
  acronym = {REM},
  projects = {REScala},
  file = {papers/2013_Ways-to-React-Comparing-Reactive-Languages-and-Complex-Event-Processing.pdf},
  author = {Margara, Alessandro and Salvaneschi, Guido},
  title = {Ways to React: Comparing Reactive Languages and Complex Event},
  year = {2013},
  month = oct,
  howpublished = {Presentation at the Workshop on Reactivity, Events and Modularity (REM '13)},
  location = {Indianapolis, IN, USA},
  keywords = {Reactive Applications, Reactive Programming, Complex Event Processing, Event-Driven Programming},
  abstract = {Reactive applications demand for detecting the changes that occur in a domain of interest and for timely reactions. Examples range from simple interactive applications to complex monitoring tasks involving distributed and heterogeneous systems.\par Over the last years, different programming paradigms and solutions have been proposed to support such applications. In this paper, we focus on two prominent approaches: event-based programming, specifically Complex Event Processing (CEP), and Reactive Languages (RLs).\par CEP systems enable the definition of high level situations of interest from low level primitive events detected in the external environment. On the other hand, RLs support time-changing values and their composition as dedicated language abstractions. These research fields have been investigated by different communities, belonging respectively to the database and the distributed systems areas and to the programming language area.\par It is our belief that a deeper understanding of these research fields, including their benefits and limitations, their similarities and differences, could drive further developments in supporting reactive applications. For this reason, we propose a first comparison of the two fields. Despite huge differences, we believe that such a comparison can trigger an interesting discussion across the communities, favor knowledge sharing, and let new ideas emerge.},
}

@article{Salvaneschi:2013:Analysis,
  acronym = {TAAS},
  file = {papers/2012_An-Analysis-of-Language-Level-Support-for-Self-Adaptive-Software.pdf},
  author = {Salvaneschi, Guido and Ghezzi, Carlo and Pradella, Matteo},
  title = {An Analysis of Language-Level Support for Self-Adaptive Software},
  year = {2013},
  month = jul,
  issue_date = {July 2013},
  journal = {ACM Transactions on Autonomous and Adaptive Systems},
  volume = {8},
  number = {2},
  articleno = {7},
  numpages = {29},
  pages = {7:1--7:29},
  publisher = {ACM},
  address = {New York, NY, USA},
  issn = {1556-4665},
  doi = {10.1145/2491465.2491466},
  keywords = {Self-Adaptive Software, Context-Oriented Programming, Autonomic Computing, Context},
  abstract = {Self-adaptive software has become increasingly important to address the new challenges of complex computing systems. To achieve adaptation, software must be designed and implemented by following suitable criteria, methods, and strategies. Past research has been mostly addressing adaptation by developing solutions at the software architecture level. This work, instead, focuses on finer-grain programming language-level solutions. We analyze three main linguistic approaches: metaprogramming, aspect-oriented programming, and context-oriented programming. The first two are general-purpose linguistic mechanisms, whereas the third is a specific and focused approach developed to support context-aware applications. This paradigm provides specialized language-level abstractions to implement dynamic adaptation and modularize behavioral variations in adaptive systems.\par The article shows how the three approaches can support the implementation of adaptive systems and compares the pros and cons offered by each solution.},
}

@inproceedings{Salvaneschi:2013:Distributed,
  acronym = {COORDINATION},
  projects = {REScala},
  file = {papers/2013_Towards-Distributed-Reactive-Programming.pdf},
  author = {Salvaneschi, Guido and Drechsler, Joscha and Mezini, Mira},
  title = {Towards Distributed Reactive Programming},
  booktitle = {Proceedings of the International Conference on Coordination Languages and Models},
  series = {COORDINATION '13},
  year = {2013},
  month = jun,
  pages = {226--235},
  editor = {De Nicola, Rocco and Julien, Christine},
  location = {Florence, Italy},
  publisher = {Springer-Verlag},
  address = {Berlin/Heidelberg, Germany},
  isbn = {978-3-642-38493-6},
  doi = {10.1007/978-3-642-38493-6_16},
  keywords = {Functional-Reactive Programming, Scala, Event-Driven Programming},
  abstract = {Reactive applications is a wide class of software that responds to user input, network messages, and other events. Recent research on reactive languages successfully addresses the drawbacks of the Observer pattern -- the traditional way reactive applications are implemented in the object-oriented setting -- by introducing time-changing values and other ad-hoc programming abstractions.},
}

@inproceedings{Salvaneschi:2013:Reactive,
  acronym = {AOSD},
  projects = {REScala},
  file = {papers/2013_Reactive-Behavior-in-Object-oriented-Applications-An-Analysis-and-a-Research-Roadmap.pdf},
  author = {Salvaneschi, Guido and Mezini, Mira},
  title = {Reactive Behavior in Object-Oriented Applications: An Analysis and a Research Roadmap},
  booktitle = {Proceedings of the 12th Annual International Conference on Aspect-Oriented Software Development},
  series = {AOSD '13},
  year = {2013},
  month = mar,
  numpages = {12},
  pages = {37--48},
  location = {Fukuoka, Japan},
  publisher = {ACM},
  address = {New York, NY, USA},
  isbn = {978-1-4503-1766-5},
  doi = {10.1145/2451436.2451442},
  keywords = {Functional-Reactive Programming, Reactive Programming, Object-Oriented Programming, Incremental Computation},
  abstract = {Reactive applications are difficult to implement. Traditional solutions based on event systems and the Observer pattern have a number of inconveniences, but programmers bear them in return for the benefits of OO design. On the other hand, reactive approaches based on automatic updates of dependencies - like functional reactive programming and dataflow languages - provide undoubted advantages but do not fit well with mutable objects. In this paper, we provide a research roadmap to overcome the limitations of the current approaches and to support reactive applications in the OO setting. To establish a solid background for our investigation, we propose a conceptual framework to model the design space of reactive applications and we study the flaws of the existing solutions. Then we highlight how reactive languages have the potential to address those issues and we formulate our research plan.},
}

@article{Salvaneschi:2012:ContextOriented,
  acronym = {JSS},
  file = {papers/2012_Context-oriented-programming-a-software-engineering-perspective.pdf},
  author = {Salvaneschi, Guido and Ghezzi, Carlo and Pradella, Matteo},
  title = {Context-Oriented Programming: A Software Engineering Perspective},
  year = {2012},
  month = aug,
  issue_date = {August, 2012},
  journal = {Journal of Systems and Software},
  volume = {85},
  number = {8},
  numpages = {17},
  pages = {1801--1817},
  publisher = {Elsevier Science Inc.},
  address = {USA},
  issn = {0164-1212},
  doi = {10.1016/j.jss.2012.03.024},
  keywords = {Context-Oriented Programming, Context, Context-Awareness},
  abstract = {The implementation of context-aware systems can be supported through the adoption of techniques at the architectural level such as middlewares or component-oriented architectures. It can also be supported by suitable constructs at the programming language level. Context-oriented programming (COP) is emerging as a novel paradigm for the implementation of this kind of software, in particular in the field of mobile and ubiquitous computing. The COP paradigm tackles the issue of developing context-aware systems at the language-level, introducing ad hoc language abstractions to manage adaptations modularization and their dynamic activation. In this paper we review the state of the art in the field of COP in the perspective of the benefits that this technique can provide to software engineers in the design and implementation of context-aware applications.},
}

@inproceedings{Salvaneschi:2012:ContextErlang,
  acronym = {AOSD},
  file = {papers/2012_ContextErlang-introducing-context-oriented-programming-in-the-actor-model.pdf},
  author = {Salvaneschi, Guido and Ghezzi, Carlo and Pradella, Matteo},
  title = {{ContextErlang}: Introducing Context-Oriented Programming in the Actor Model},
  booktitle = {Proceedings of the 11th Annual International Conference on Aspect-Oriented Software Development},
  series = {AOSD '12},
  year = {2012},
  month = mar,
  numpages = {12},
  pages = {191--202},
  location = {Potsdam, Germany},
  publisher = {ACM},
  address = {New York, NY, USA},
  isbn = {978-1-4503-1092-5},
  doi = {10.1145/2162049.2162072},
  keywords = {self-Adaptive Software, Erlang, OTP Platform, Context-Oriented Programming},
  abstract = {Self-adapting systems are becoming widespread in emerging fields such as autonomic, mobile and ubiquitous computing. Context-oriented programming (COP) is a promising language-level solution for the implementation of context-aware, self-adaptive software. However, current COP approaches struggle to effectively manage the asynchronous nature of context provisioning. We argue that, to solve these issues, COP features should be designed to fit nicely in the concurrency model supported by the language. This work presents the design rationale of ContextErlang, which introduces COP in the Actor Model. We provide evidence that ContextErlang constitutes a viable solution to implement context-aware software in a highly concurrent and distributed setting. We discuss a case study and an evaluation of run-time performance.},
}

@inbook{Salvaneschi:2011:Metrics,
  author = {Salvaneschi, Guido and Salvaneschi, Paolo},
  title = {Metrics of Software Security},
  booktitle = {Encyclopedia of Cryptography and Security, 2nd Ed},
  year = {2011},
  pages = {775--778},
  editor = {van Tilborg, Henk C. A. and Jajodia, Sushil},
  publisher = {Springer US},
  address = {Boston, MA, USA},
  isbn = {978-1-4419-5906-5},
  doi = {10.1007/978-1-4419-5906-5_680},
  abstract = {Measuring software security requires to identify measurable properties of a software artifact and to build models that can relate the measures to a qualitative or quantitative value of the property ``security''.},
}

@inproceedings{Maggi:2011:Finding,
  acronym = {ICISS},
  file = {papers/2011_Finding-Non-trivial-Malware-Naming-Inconsistencies.pdf},
  author = {Maggi, Federico and Bellini, Andrea and Salvaneschi, Guido and Zanero, Stefano},
  title = {Finding Non-Trivial Malware Naming Inconsistencies},
  booktitle = {Proceedings of the 7th International Conference on Information Systems Security},
  series = {ICISS '11},
  year = {2011},
  month = dec,
  numpages = {16},
  pages = {144--159},
  location = {Kolkata, India},
  publisher = {Springer-Verlag},
  address = {Berlin/Heidelberg, Germany},
  isbn = {978-3-642-25559-5},
  doi = {10.1007/978-3-642-25560-1_10},
  abstract = {Malware analysts, and in particular antivirus vendors, never agreed on a single naming convention for malware specimens. This leads to confusion and difficulty---more for researchers than for practitioners---for example, when comparing coverage of different antivirus engines, when integrating and systematizing known threats, or comparing the classifications given by different detectors. Clearly, solving naming inconsistencies is a very difficult task, as it requires that vendors agree on a unified naming convention. More importantly, solving inconsistencies is impossible without knowing exactly where they are. Therefore, in this paper we take a step back and concentrate on the problem of finding inconsistencies. To this end, we first represent each vendor's naming convention with a graph-based model. Second, we give a precise definition of inconsistency with respect to these models. Third, we define two quantitative measures to calculate the overall degree of inconsistency between vendors. In addition, we propose a fast algorithm that finds non-trivial (i.e., beyond syntactic differences) inconsistencies. Our experiments on four major antivirus vendors and 98,798 real-world malware samples confirm anecdotal observations that different vendors name viruses differently. More importantly, we were able to find inconsistencies that cannot be inferred at all by looking solely at the syntax.},
}

@inproceedings{Salvaneschi:2011:JavaCtx,
  acronym = {COP},
  file = {papers/2011_JavaCtx-Seamless-Toolchain-Integration-for-Context-Oriented-Programming.pdf},
  author = {Salvaneschi, Guido and Ghezzi, Carlo and Pradella, Matteo},
  title = {{JavaCtx}: Seamless Toolchain Integration for Context-Oriented Programming},
  booktitle = {Proceedings of the 3rd International Workshop on Context-Oriented Programming},
  series = {COP '11},
  year = {2011},
  month = jul,
  articleno = {4},
  numpages = {6},
  pages = {4:1--4:6},
  location = {Lancaster, UK},
  publisher = {ACM},
  address = {New York, NY, USA},
  isbn = {978-1-4503-0891-5},
  doi = {10.1145/2068736.2068740},
  keywords = {Self-Adaptive Software, Context-Oriented Programming, Context, Aspect-Oriented Programming},
  abstract = {Context-oriented programming is an emerging paradigm addressing at the language level the issue of dynamic software adaptation and modularization of context-specific concerns. In this paper we propose JavaCtx, a tool which employs coding conventions to generate the context-aware semantics for Java programs and subsequently weave it into the application. The contribution of JavaCtx is twofold: the design of a set of coding conventions which allow to write context-oriented software in plain Java and the concept of context-oriented semantics injection, which allows to introduce the context-aware semantics through standard aspect-oriented programming. Both of these points allow to seamless integrate JavaCtx in the existing industrial-strength appliances and so ease the development of context-oriented software in consolidated industrial settings.},
}

@inproceedings{Ghezzi:2011:Evaluation,
  acronym = {SEAMS},
  file = {papers/2011_An-Evaluation-of-the-Adaptation-Capabilities-in-Programming-Languages.pdf},
  author = {Ghezzi, Carlo and Pradella, Matteo and Salvaneschi, Guido},
  title = {An Evaluation of the Adaptation Capabilities in Programming Languages},
  booktitle = {Proceedings of the 6th International Symposium on Software Engineering for Adaptive and Self-Managing Systems},
  series = {SEAMS '11},
  year = {2011},
  month = may,
  numpages = {10},
  pages = {50--59},
  location = {Waikiki, Honolulu, HI, USA},
  publisher = {ACM},
  address = {New York, NY, USA},
  isbn = {978-1-4503-0575-4},
  doi = {10.1145/1988008.1988016},
  keywords = {Self-Adaptive Software, Context, Context-Oriented Programming},
  abstract = {In recent years the need for software applications to adapt to the environment in which they are situated has become common. Beside architectural approaches, language-level support for the development of adaptable and context-aware software have been investigated. Many existing solutions adopt ad hoc programming paradigms such as aspect oriented programming (AOP) or context oriented programming (COP). In this paper we investigate the use of the abstractions offered by traditional object-oriented and functional paradigms for the development of context-adaptable systems. We carry out our analysis along a set of conceptual directions which consider the requirement of functional adaptation beside non functional requirements such as safety and effective modularization. Our analysis were validated though the development of several prototypes of an adaptable cache server which is chosen as the running example through the paper. We provide an estimation of the performance advantages of the techniques based traditional programming languages compared with context-oriented programming.},
}

@misc{Salvaneschi:2011:ContextOriented,
  acronym = {CoRR},
  author = {Salvaneschi, Guido and Ghezzi, Carlo and Pradella, Matteo},
  title = {Context-Oriented Programming: A Programming Paradigm for Autonomic Systems},
  year = {2011},
  month = apr,
  eprint = {1105.0069},
  eprinttype = {arXiv},
  keywords = {Context, Self-Adaptative Software, Context-Oriented Programming, Autonomic Computing},
  abstract = {Dynamic software adaptability is one of the central features leveraged by autonomic computing. However, developing software that changes its behavior at run time adapting to the operational conditions is a challenging task. Several approaches have been proposed in the literature to attack this problem at different and complementary abstraction levels: software architecture, middleware, and programming level. We focus on the support that ad-hoc programming language constructs may provide to support dynamically adaptive behaviors. We introduce context-oriented programming languages and we present a framework that positions the supported paradigm in the MAPE-K autonomic loop. We discuss the advantages of using context-oriented programming languages instead of other mainstream approaches based on dynamic aspect-oriented programming languages. We present a preliminary case study that shows how the proposed programming style naturally fits dynamic adaptation requirements and we extensively evaluate the use of COP in this scenario. Finally, we discuss some known problems and outline a number of open research challenges.},
}

@inproceedings{Ghezzi:2010:Context,
  acronym = {COP},
  file = {papers/2010_Context-Oriented-Programming-in-Highly-Concurrent-Systems.pdf},
  author = {Ghezzi, Carlo and Pradella, Matteo and Salvaneschi, Guido},
  title = {Context Oriented Programming in Highly Concurrent Systems},
  booktitle = {Proceedings of the 2nd International Workshop on Context-Oriented Programming},
  series = {COP '10},
  year = {2010},
  month = jun,
  articleno = {1},
  numpages = {3},
  pages = {1:1--1:3},
  location = {Maribor, Slovenia},
  publisher = {ACM},
  address = {New York, NY, USA},
  isbn = {978-1-4503-0531-0},
  doi = {10.1145/1930021.1930022},
  keywords = {Context-Oriented Programming, Self-Adaptive Software, Erlang, OTP Platform, Context},
  abstract = {Context Oriented Programming (COP) allows modularization of programs according to the cross-cutting concern of contexts. Context depending features are grouped in layers which can be activated at run time by triggering the associated behavioral variations.\par COP extensions have been provided for different languages. However all of them enforce a thread, shared-memory based concurrency model. In this paper we discuss how the COP paradigm can be applied to message-based concurrent systems which support the agents paradigm. The discussion is supported by the case of ContextErlang, our COP-inspired contextual version of Erlang.},
}

@inproceedings{Comparetti:2010:Identifying,
  acronym = {SP},
  file = {papers/2010_Identifying-Dormant-Functionality-in-Malware-Programs.pdf},
  author = {Comparetti, Paolo Milani and Salvaneschi, Guido and Kirda, Engin and Kolbitsch, Clemens and Kruegel, Christopher and Zanero, Stefano},
  title = {Identifying Dormant Functionality in Malware Programs},
  booktitle = {Proceedings of the 2010 IEEE Symposium on Security and Privacy},
  series = {SP '10},
  year = {2010},
  month = jun,
  numpages = {16},
  pages = {61--76},
  location = {Oakland, CA, USA},
  publisher = {IEEE Computer Society},
  address = {Washington, DC, USA},
  isbn = {978-0-7695-4035-1},
  doi = {10.1109/SP.2010.12},
  keywords = {Malware Analysis, Dormant Functionality, Binary Analysis},
  abstract = {To handle the growing flood of malware, security vendors and analysts rely on tools that automatically identify and analyze malicious code. Current systems for automated malware analysis typically follow a dynamic approach, executing an unknown program in a controlled environment (sandbox) and recording its runtime behavior. Since dynamic analysis platforms directly run malicious code, they are resilient to popular malware defense techniques such as packing and code obfuscation. Unfortunately, in many cases, only a small subset of all possible malicious behaviors is observed within the short time frame that a malware sample is executed. To mitigate this issue, previous work introduced techniques such as multi-path or forced execution to increase the coverage of dynamic malware analysis. Unfortunately, using these techniques is potentially expensive, as the number of paths that require analysis can grow exponentially. In this paper, we propose Reanimator, a novel solution to determine the capabilities (malicious functionality) of malware programs. Our solution is based on the insight that we can leverage behavior observed while dynamically executing a specific malware sample to identify similar functionality in other programs. More precisely, when we observe malicious actions during dynamic analysis, we automatically extract and model the parts of the malware binary that are responsible for this behavior. We then leverage these models to check whether similar code is present in other samples. This allows us to statically identify dormant functionality (functionality that is not observed during dynamic analysis) in malicious programs. We evaluate our approach on thousands of real-world malware samples, and we show that our system is successful in identifying additional, malicious functionality. As a result, our approach can significantly improve the coverage of malware analysis results.},
}

@inproceedings{Ghezzi:2010:Programming,
  acronym = {SEAMS},
  file = {papers/2010_Programming-Language-Support-to-Context-Aware-Adaptation-A-Case-Study-with-Erlang.pdf},
  author = {Ghezzi, Carlo and Pradella, Matteo and Salvaneschi, Guido},
  title = {Programming Language Support to Context-Aware Adaptation: A Case-Study with Erlang},
  booktitle = {Proceedings of the 2010 ICSE Workshop on Software Engineering for Adaptive and Self-Managing Systems},
  series = {SEAMS '10},
  year = {2010},
  month = may,
  numpages = {10},
  pages = {59--68},
  location = {Cape Town, South Africa},
  publisher = {ACM},
  address = {New York, NY, USA},
  isbn = {978-1-60558-971-8},
  doi = {10.1145/1808984.1808991},
  keywords = {Erlang, Context-Oriented Programming, Context, Self-Adaptative Software, OTP Platform},
  abstract = {Software applications are increasingly situated in a world where context changes continuously. At the same time, applications need to provide continuous service, and the service provided often needs to change in order to adapt to the new contexts. Context-aware adaptation can be greatly facilitated by using programming languages that natively support high-level features to deal with contexts, context changes, and context-aware behaviors. Although context-oriented programming has been around for a while, most existing efforts focus on incorporating context-oriented features in languages that are not primarily oriented to concurrency, distribution, and dynamic reconfiguration. These features, however, characterize most pervasive context-aware situations. In this work, we illustrate how context-aware programming primitives may introduced in the parallel and distributed Erlang programming language. We also present an extended example, which illustrates the benefits of using our extension (ContextErlang) to design context-aware pervasive applications.},
}

@inproceedings{Ghezzi:2010:Automatic,
  acronym = {FASE},
  author = {Ghezzi, Carlo and Mocci, Andrea and Salvaneschi, Guido},
  title = {Automatic Cross Validation of Multiple Specifications: A Case Study},
  booktitle = {Proceedings of the 13th International Conference on Fundamental Approaches to Software Engineering},
  series = {FASE '10},
  year = {2010},
  month = mar,
  numpages = {15},
  pages = {233--247},
  location = {Paphos, Cyprus},
  publisher = {Springer-Verlag},
  address = {Berlin/Heidelberg, Germany},
  isbn = {3-642-12028-8},
  doi = {10.1007/978-3-642-12029-9_17},
  abstract = {The problem of formal software specification has been addressed and discussed since the infancy of software engineering. However, among all the proposed solutions, none is universally accepted yet. Many different formal descriptions can in fact be given for the same software component; thus, the problem of determining the consistency relation among those descriptions becomes relevant and potentially critical. In this work, we propose a method for comparing two specific kinds of formal specifications of containers. In particular, we check the consistency of intensional behavior models with algebraic specifications. The consistency check is performed by generating a behavioral equivalence model from the intensional model, converting the algebraic axioms into temporal logic formulae, and then checking them against the model by using the NuSMV model checker. An automated software tool which encodes the problem as model checking has been implemented to check the consistency of recovered specifications of relevant Java classes.},
}

@inproceedings{Criscione:2009:Integrated,
  acronym = {EC2ND},
  file = {papers/2009_Integrated-Detection-of-Attacks-Against-Browsers-Web-Applications-and-Databases.pdf},
  author = {Criscione, Claudio and Salvaneschi, Guido and Maggi, Federico and Zanero, Stefano},
  title = {Integrated Detection of Attacks Against Browsers, Web Applications and Databases},
  booktitle = {Proceedings of the 2009 European Conference on Computer Network Defense},
  series = {EC2ND '09},
  year = {2009},
  month = nov,
  numpages = {9},
  pages = {37--45},
  location = {Milano, Italy},
  publisher = {IEEE Computer Society},
  address = {Washington, DC, USA},
  isbn = {978-0-7695-3983-6},
  doi = {10.1109/EC2ND.2009.13},
  abstract = {Anomaly-based techniques were exploited successfully to implement protection mechanisms for various systems. Recently, these approaches have been ported to the web domain under the name of "web application anomaly detectors" (or firewalls) with promising results. In particular, those capable of automatically building specifications, or models, of the protected application by observing its traffic (e.g., network packets, system calls, or HTTP requests and responses) are particularly interesting, since they can be deployed with little effort.\par Typically, the detection accuracy of these systems is significantly influenced by the model building phase (often called training), which clearly depends upon the quality of the observed traffic, which should resemble the normal activity of the protected application and must be also free from attacks. Otherwise, detection may result in significant amounts of false positives (i.e., benign events flagged as anomalous) and negatives (i.e., undetected threats).\par In this work we describe Masibty, a web application anomaly detector that have some interesting properties. First, it requires the training data not to be attack-free. Secondly, not only it protects the monitored application, it also detects and blocks malicious client-side threats before they are sent to the browser. Third, Masibty intercepts the queries before they are sent to the database, correlates them with the corresponding HTTP requests and blocks those deemed anomalous.\par Both the accuracy and the performance have been evaluated on real-world web applications with interesting results. The system is almost not influenced by the presence of attacks in the training data and shows only a negligible amount of false positives, although this is paid in terms of a slight performance overhead.},
}

